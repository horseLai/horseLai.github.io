<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Retrofit 源码分析</title>
      <link href="/2019/06/02/Retrofit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/Retrofit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><code>Retrofit</code>和 <code>OKHttp</code>同为 <code>square</code> 出品的网络请求相关库，不同的是 <code>Retrofit</code>本身不进行网络请求，而是作为一个协调者，协调其他组件共同处理网络请求。用官网描述来说就是：<code>Retrofit</code>是可插拔的，它允许不同的执行机制和类库用于执行<code>HTTP</code>请求、允许不同序列化的类库进行<code>java</code>实体类与<code>HTTP</code>响应数据之间转换。</p><p><code>Retrofit</code>的网络请求部分默认基于<code>OkHttp</code>，关于<code>OkHttp</code>，鄙人写过 <a href="https://www.jianshu.com/p/ac5bc7698553" target="_blank" rel="noopener"><code>OkHttp源码分析</code></a>一文，感兴趣的童鞋可以看看。</p><p>本文纯属基于个人理解，源码解析不限于执行流程，因此受限于知识水平，有些地方可能依然没有理解到位，还请发现问题的童鞋理性指出。</p><a id="more"></a><blockquote><p><strong>温馨提示：本文源码基于 <code>Retrofit-2.4.0</code></strong></p></blockquote><h3 id="二、流程分析"><a href="#二、流程分析" class="headerlink" title="二、流程分析"></a>二、流程分析</h3><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h4><p>这里以请求 <a href="http://wanandroid.com" target="_blank" rel="noopener">玩Android</a> 首页数据为例，演示使用<code>Retrofit</code>进行网络请求的最基本方式。</p><p>首先如下初始化 <code>Retrofit</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeRetrofit</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .baseUrl(<span class="string">"http://wanandroid.com"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如下建立请求接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;page&#125;/json"</span>)</span><br><span class="line">    <span class="keyword">public</span> Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; getHomeList(<span class="meta">@Path</span>(<span class="string">"page"</span>)<span class="keyword">int</span> page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着如下调用请求、处理响应数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHomeList</span><span class="params">(<span class="keyword">int</span> page, ResCallback&lt;ResponseEntry&lt;ResponseData&gt;&gt; callback)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>)</span><br><span class="line">        service = retrofit.create(Service.class);</span><br><span class="line">    service.getHomeList(page).enqueue(<span class="keyword">new</span> Callback&lt;ResponseEntry&lt;ResponseData&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; call, Response&lt;ResponseEntry&lt;ResponseData&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">                System.out.println(response.message());</span><br><span class="line">                System.out.println(response.code());</span><br><span class="line">                System.out.println(response.headers());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                    ResponseEntry&lt;ResponseData&gt; body = response.body();</span><br><span class="line">                    <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        callback.onFailed(<span class="keyword">new</span> Exception(<span class="string">"body is null !!"</span>));</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    callback.onSuccess(body);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">上面可以注意到的一点是，不同于直接使用`OkHttp`，这里`response.body()`可以直接拿到我们需要的解析好的`Java`实体类了，而不需要再做`Json`数据解析工作， 它的使用过程如下：</span><br><span class="line"></span><br><span class="line">![Retrofit使用过程](https:<span class="comment">//upload-images.jianshu.io/upload_images/5879616-a5898157d2d31694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">而一般来说，我们使用`OkHttp`进行网络请求的使用过程如下：</span><br><span class="line"></span><br><span class="line">![一般OkHttp使用过程](https:<span class="comment">//upload-images.jianshu.io/upload_images/5879616-791301aa8a1c3917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">显然 `Retrofit` 的目的就是把网络请求、响应数据解析等相互分离的操作都整合到一起，达到 `All in one` 的效果，而实际请求和解析都是以可插拔的插件形式存在，灵活度非常高。</span><br><span class="line"></span><br><span class="line">#### 2. 创建服务到建立`Call`过程分析</span><br><span class="line"></span><br><span class="line">关于 **`Retrofit`的构建** ，我们注意一下必填参数以及默认参数即可，根据如下`Retrofit.Build#build`源码可知：</span><br><span class="line">- `baseUrl`必填</span><br><span class="line">- 默认`callFactory`为`OkHttpClient`；默认`callbackExecutor`（回调执行器）在`Android`中是主线程的`Handler`；默认会先添加`Retrofit`内部的转换器，然后是其他，比如我们自定义的转换器，这是为了避免内部转换器的行为被复写掉，以及确保使用消耗(`consume`)所有类型的转换器时能有正确的行为。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// baseUrl必填</span></span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认Call工厂为 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认回调执行器为主线程Handler</span></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125; </span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"> </span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize()); </span><br><span class="line">    <span class="comment">// 这里会先添加Retrofit内部的转换器再添加我们自定的转换器</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">    converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关注一下<code>Android</code> 平台的回调执行器，因为回调执行在主线程的<code>Handler</code>上，因此可以在回调中直接操作<code>UI</code>控件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="comment">// UI线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来分析一下<strong>使用<code>Retrofit#create</code>创建一个请求服务实例时发生了什么</strong>，<code>Retrofit#create</code>源码如下，可知：</p><ul><li><p>首先需要确定的是<code>service</code>本身是个接口，并且不继承于其他接口。</p></li><li><p>然后重点来了，<code>eagerlyValidateMethods</code>会通过反射获取<code>service</code>接口中所有的方法，接着尝试从<code>ServiceMethod</code>缓存池中查找对应于各个方法的<code>ServiceMethod</code>，如果没找到的话，则重新通过<code>ServiceMethod.parseAnnotations</code>去解析各个方法的注解，解析完成后将返回的<code>ServiceMethod</code>（这里返回的<code>ServiceMethod</code>其实是实现类<code>HttpServiceMethod</code>，<code>HttpServiceMethod</code>会负责根据解析的注解参数创建<code>Call</code>，并在<code>HttpServiceMethod#invoke</code>调用时执行网络请求）存入缓存池中，方便后续复用，这里缓存池的作用跟线程池的概念异曲同工，都是为了减少因为每次都解析（创建）而造成的不必要的性能损耗，所以干脆花点内存存起来省事儿。<code>eagerlyValidateMethods</code>执行过程如下：</p><p>  <img src="https://upload-images.jianshu.io/upload_images/5879616-d7c53603bc4a38ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eagerlyValidateMethods执行过程"></p></li><li><p>接着通过<code>Proxy.newProxyInstance</code>给服务接口创建一个代理实例，实际可转成对应接口的类型，这里主要关注一下<code>InvocationHandler</code>, 每个<code>Proxy</code>对象实例都会绑定一个<code>InvocationHandler</code>对象，当执行<code>Proxy#invok</code>方法时，最终对派发给<code>InvocationHandler#invok</code>，也就是说，我们通过服务接口实例调用接口方法时，最终都会通过<code>InvocationHandler#invok</code>去执行。<code>invoke</code>方法执行链如下：</p><p>  <img src="https://upload-images.jianshu.io/upload_images/5879616-d7709fd1103cbc27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invoke执行链"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation. </span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里实际最终执行的是 HttpServiceMethod#invoke(..)</span></span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 7.0 以前版本都是 false，Android 7.0 及以上则根据 `isDefaultMethod`的复写值决定</span></span><br><span class="line">      <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; </span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">        <span class="comment">// 先从服务方法缓存中获取</span></span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此前没有解析，则重新解析注解</span></span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        <span class="comment">// 然后将解析结果添加到缓存，以便后续复用</span></span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>parseAnnotations</code> 执行链如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-4738f224f51b738d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseAnnotations执行链"></p><p>我们顺着这条链看看，首先是<code>ServiceMethod#parseAnnotations</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 解析方法的注解参数，保存在 RequestFactory</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 2. 使用将上面解析的参数建立Call，用于网络请求</span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是<code>RequestFactory#parseAnnotations</code>，源码如下，主要做了三件事情，看注释即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 解析每个方法的注解</span></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="comment">// 2. 解析方法参数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 3. 创建 RequestFactory 保存参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接着是 `HttpServiceMethod#parseAnnotations`，源码如下：</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取 Call 适配器</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 2. 获取响应数据转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    <span class="comment">// 3. 根据解析的参数创建 HttpServiceMethod</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpServiceMethod#invok</code>执行时源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 OkHttpCall, 用于进行网络请求和响应数据转换</span></span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">      <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，便是一个服务接口从解析到创建成一个<code>OkHttp#Call</code>的过程，纵观全局，其实这个过程就好比一个为了将如下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;page&#125;/json"</span>)</span><br><span class="line">    <span class="keyword">public</span> Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; getHomeList(<span class="meta">@Path</span>(<span class="string">"page"</span>)<span class="keyword">int</span> page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析成一个请求链接为<code>http://wanandroid.com/article/list/0/json</code>，请求方式为 <code>GET</code>，请求的调用方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Service service = ...;</span><br><span class="line"><span class="comment">// 相当于执行 HttpServiceMethod#invoke 方法</span></span><br><span class="line">Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; = service.getHomeList(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>的过程，而这个过程中需要解决将接口转换成对象实例、将方法注解、参数解析处理拼接为请求连接、最后确定返回类型的问题，此时<code>Call</code>尚未进行请求；</p><p><strong>3. <code>Call</code>请求执行到响应数据回调过程分析</strong></p><p>关于<code>OkHttp#Call</code>如何运作的问题已经在 <a href="https://www.jianshu.com/p/ac5bc7698553" target="_blank" rel="noopener">OkHttp源码解析</a> 一文中做了详细分析，这里的不同之处在于，在<code>Retrofit</code>中我们需要更多地关注它是如何协调请求和响应，最终回调给<code>UI</code>线程的。</p><p>OK，从<code>HttpServiceMethod#invoke</code>出发，根据前面的内容中我们已经知道它会通过<code>callAdapter.adapt(new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter))</code>返回一个<code>Call</code>实例，并且在<code>Android</code>平台上会将响应数据回调在<code>UI</code>线程的<code>Handler</code>上，因此我们先关注一下<code>Android</code>平台下的默认<code>CallAdapter</code>，于是定位到<code>Android#defaultCallAdapterFactories</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">    <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    <span class="keyword">return</span> singletonList(<span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见<code>Android</code>平台下的默认<code>CallAdapter</code>是<code>ExecutorCallAdapterFactory</code>, 于是可以定位到<code>ExecutorCallAdapterFactory#adapt</code>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorCallbackCall</code>这里实际是使用了装饰器模式，它将工作委托给了<code>callbackExecutor</code>和<code>delegate</code>，而它自身仅仅起到了协调作用，将响应数据回调到<code>UI</code>线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">   <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">     <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">     <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">     checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line">     delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 回调至主线程</span></span><br><span class="line">         callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (delegate.isCanceled()) &#123; </span><br><span class="line">               callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;   <span class="comment">// ...</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;   <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>具体到网络请求的执行与响应数据的转换工作还得看<code>OkHttpCall</code>，这里我们只关注一下<code>OKHttpCall#enqueue</code>即可， 可见这里除了请求网络数据外，还会先转换响应数据后再回调给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line">    <span class="comment">// 1. 执行请求</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 解析响应数据，将网络响应数据转换成指定数据类型</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 将解析完成的数据回调给上一级</span></span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// ... </span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后`parseResponse`部分源码如下，可见这里会通过`Converter`网络响应数据转换为我们指定的数据类型：</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line">  <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body(); </span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过转换器转换数据 </span></span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>综上可知，最终网络请求会在<code>OkHttpCall</code>中执行，获取响应数据后通过设定的<code>Converter</code>转换器将数据转换成指定类型；而最终回调给<code>UI</code>线程则是在<code>ExecutorCallbackCall</code>中进行，作为装饰器，它实际将请求和响应数据处理工作都委托给了<code>OkHttpCall</code>，而自身仅仅做了最终数据的回调处理。</p><p>于是整体执行流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-e090d2faa34a455a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体执行流程"></p><h3 id="三、Proxy"><a href="#三、Proxy" class="headerlink" title="三、Proxy"></a>三、Proxy</h3><p>这里指的是反射工具类中的<code>java.lang.reflect.Proxy</code>，通过前面的分析，我们已经知道，我们建立的服务接口会通过<code>Proxy.newProxyInstance</code>来实例化一个代理对象实例，而通过这个实例化的对象，就能像使用普通类对象实例一个调用方法。</p><p><strong>这里我比较好奇的是它是如何给接口实例化的</strong>，因此咱就来研究研究，定位到<code>Proxy#newProxyInstance</code>，精简一下源码（去除了验证逻辑等），如下，可以发现<code>Proxy</code>会为我们的服务接口构建一个代理类（当然会先从代理类缓存,也就是<code>WeakCache</code>中查找已经构建的代理类），然后通过这个类的构造函数构建出一个实例对象出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone(); </span><br><span class="line">    <span class="comment">// 1. 从 `WeakCache`中查找，或者创建一个接口的代理类 </span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">// 2. 拿到代理类的构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">    <span class="keyword">final</span> InvocationHandler ih = h; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 通过构造函数创建一个实例对象</span></span><br><span class="line">    <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>getProxyClass0()</code>, 根据代码注释可知，如果根据类加载器查找已经实现的代理类，那么直接返回拷贝的缓存，如果没找到，那么就会通过<code>ProxyClassFactory</code>去创建一个代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是再来看看<code>ProxyClassFactory</code>，可知通过其<code>apply</code>方法会根据我们服务接口的信息配置代理类，然后通过<code>ProxyGenerator</code>生成一个代理类<code>class</code>文件，最终通过<code>defineClass0</code>将这个代理类定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">        <span class="comment">// 1. 进行一系列的代理类信息的配置</span></span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">        <span class="comment">// 2. 根据配置信息生成代理类class文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="comment">// 3. 最终生成特定代理类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>defineClass0</code>是个<code>native</code>方法，因此就不再深挖了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(ClassLoader loader, String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure><p>至此，是不是已经明白了<code>Proxy</code>如何实例化接口的呢？</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>通过上面的分析，可以发现 <code>Retrofit</code> 更像是对一个<code>OkHttp</code>请求的抽取与封装：</p><ul><li>网络请求参数全部抽离成服务接口方法的注解，注解参数解析和<code>Request</code>构建工作抽离到了<code>RequestFactory</code>。</li><li><code>CallAdapter</code>将<code>OkHttpCall</code>的执行匹配到我们指定的执行器，而<code>Converter</code>则将网络响应数据转换成我们想要的类型</li><li>最终，在<code>Android</code>平台上直接将指定的数据类型返回给<code>UI</code>线程的<code>Handler</code>处理。</li></ul><p>关于<code>Proxy</code>，它将服务接口转换成一个代理类对象实例的实现方式也很值得我们学习。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 源码分析</title>
      <link href="/2019/06/02/OkHttp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/OkHttp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>在我们日常开发中，<code>OkHttp</code>可谓是最常用的开源库之一，目前就连<code>Android API</code>中的网络请求接口都是用的<code>OkHttp</code>，好吧，真的很强。</p><p>在上学期间我也曾阅读和分析过<code>OkHttp</code>的源码，并记录在笔记中，不过现在再去翻看的时候发现当时很多地方并没有正确理解，因此也趁着这个过年假期重新阅读和整理一遍，感兴趣的童鞋可以观摩一下。</p><p>本文纯属基于个人理解，因此受限于知识水平，有些地方可能依然没有理解到位，还请发现问题的童鞋理性指出。</p><a id="more"></a><blockquote><p><strong>温馨提示： 本文很长，源码基于 <code>OKHttp-3.11.0</code></strong></p></blockquote><h3 id="二、从一个简单请求入手分析整体运作流程"><a href="#二、从一个简单请求入手分析整体运作流程" class="headerlink" title="二、从一个简单请求入手分析整体运作流程"></a>二、从一个简单请求入手分析整体运作流程</h3><h4 id="1-先来点关于-OkHttpClient-的官方释义"><a href="#1-先来点关于-OkHttpClient-的官方释义" class="headerlink" title="1. 先来点关于 OkHttpClient 的官方释义"></a>1. 先来点关于 OkHttpClient 的官方释义</h4><p><code>OkHttpClient</code>作为<code>Call</code>的工厂类，用于发送<code>HTTP</code>请求并读取相应数据。</p><p><strong><code>OkHttpClient</code>应当被共享</strong>.</p><p>使用<code>OkHttpClient</code>的最佳使用方式是创建一个<code>OkHttpClient</code>单例，然后复用这个单例进行所有的<code>HTTP</code>请求。为啥呢？因为每个<code>OkHttpClient</code>自身都会持有一个连接池和线程池，所以符用连接和线程可以减少延迟、节约内存。相反地，如果给每个请求都创建一个<code>OkHttpClient</code>的话，那就是浪费闲置线程池的资源。</p><p>可以如下使用<code>new OkHttpClient()</code>创建一个默认配置的共享<code>OkHttpClient</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final OkHttpClient client = new OkHttpClient();</span><br></pre></td></tr></table></figure><p>或使用 <code>new OkHttpClient.Builder()</code>来创建一个自定义配置的共享实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(new HttpLoggingInterceptor())</span><br><span class="line">    .cache(new Cache(cacheDir, cacheSize))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p><strong>可以通过<code>newBuilder()</code>来自定义<code>OkHttpClient</code></strong>，这样创建出来的<code>OkHttpClient</code>具有与原对象相同的连接池、线程池和配置。使用这个方法可以派生一个具有自己特殊配置的<code>OkHttpClient</code>以符合我们的特殊要求。</p><p>如下示例演示的就是如何派生一个读超时为500毫秒的<code>OkHttpClient</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient eagerClient = client.newBuilder()</span><br><span class="line">    .readTimeout(500, TimeUnit.MILLISECONDS)</span><br><span class="line">    .build();</span><br><span class="line">Response response = eagerClient.newCall(request).execute();</span><br></pre></td></tr></table></figure><p><strong>关闭（<code>Shutdown</code>）不是必须的</strong>。</p><p>线程和连接会一直被持有，直到当它们保持闲置时自动被释放。但是如果你编写的应用需要主动释放无用资源，那么你也可以主动去关闭。通过<code>shutdown()</code>方法关闭分发器<code>dispatcher</code>的执行服务，这将导致之后<code>OkHttpClient</code>收到的请求全部被拒绝掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.dispatcher().executorService().shutdown();</span><br></pre></td></tr></table></figure><p>清空连接池可以用<code>evictAll()</code>,不过连接池的守护线程可能不会马上退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.connectionPool().evictAll();</span><br></pre></td></tr></table></figure><p>如果相关比缓存，可以调用<code>close()</code>，注意如果缓存已经关闭了再创建<code>call</code>的话就会出现错误，并且会导致<code>call</code>崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.cache().close();</span><br></pre></td></tr></table></figure><p><code>OkHttp</code>同样会为所有<code>HTTP/2</code>连接建立守护线程，并且再它们保持闲置状态时自动关闭掉它们。</p><h4 id="2-常规使用"><a href="#2-常规使用" class="headerlink" title="2. 常规使用"></a>2. 常规使用</h4><p>上面的官方释义描述了<code>OkHttpClient</code>的最佳实践原则和清理操作，接下来我们根据一个简单的<code>GET</code>请求操作来引出我们要分析的问题：</p><p>如下创建一个<code>OkHttpClient</code>实例，添加了<code>Intercepter</code>，并在工程目录下建了个名为<code>cache</code>的<code>Cache</code>缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Interceptor logInterceptor = chain -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    System.out.println(request.url());</span><br><span class="line">    System.out.println(request.method());</span><br><span class="line">    System.out.println(request.tag());</span><br><span class="line">    System.out.println(request.headers());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .cache(<span class="keyword">new</span> Cache(<span class="keyword">new</span> File(<span class="string">"cache/"</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">        .addInterceptor(logInterceptor)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>然后一个普通的<code>GET</code>请求是这样的，这里以获取 <a href="http://wanandroid.com" target="_blank" rel="noopener">玩Android</a> 首页列表为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHomeList</span><span class="params">(<span class="keyword">int</span> page)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 建立HTTP请求</span></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(String.format(<span class="string">"http://wanandroid.com/article/list/%d/json"</span>, page))</span><br><span class="line">            .get()</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2. 基于 Request创建 Call</span></span><br><span class="line">    okhttp3.Call call = okHttpClient.newCall(request);</span><br><span class="line">    <span class="comment">// 3. 执行Call</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(response.message());</span><br><span class="line">            System.out.println(response.code());</span><br><span class="line">            System.out.println(response.headers());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                ResponseBody body = response.body();</span><br><span class="line">                <span class="keyword">if</span> (body == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(body.string());</span><br><span class="line">                <span class="comment">// 每个ResponseBody只能使用一次，使用后需要手动关闭</span></span><br><span class="line">                body.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-执行流程分析"><a href="#3-执行流程分析" class="headerlink" title="3. 执行流程分析"></a>3. 执行流程分析</h4><p>注意到上面的<code>okHttpClient.newCall(request)</code>，对应的源码如下，可知它创建的实际上是<code>Call</code>的实现类<code>RealCall</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);  </span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Call</code>提供请求任务的执行和取消和相关状态操作方法。类似于<code>FutureTask</code>，是任务执行单元，其核心的执行方法代码如下，包含同步执行(<code>execute()</code>)和异步执行(<code>enqueue()</code>)两种方式。<strong>对于同步方法而言，<code>RealCall</code>仅仅通过<code>executed()</code>方法将自身记录在<code>Dispatcher</code>（分发器）的同步请求队列中，这是为了在分发器中统计请求数量，在请求结束之后则通过<code>finished()</code>方法将自身从分发器中的同步请求队列中移除，而真正进行数据请求的是在拦截器<code>Intercepter</code></strong>，如下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 仅仅将这个 Call记录在分发器 ( Dispatcher )的同步执行队列中</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 2. 通过拦截器链获取响应数据，这里才会真正的执行请求</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 3.  拿到响应数据后从分发器的同步执行队列中移除当前请求</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进至<code>getResponseWithInterceptorChain()</code>，可以注意到，除了我们在创建<code>OkHttpClient</code>时添加的拦截器外，每个<code>HTTP</code>请求都会默认添加几个固有的拦截器，如<br><code>RetryAndFollowUpInterceptor</code>、<code>BridgeInterceptor</code>、<code>CacheInterceptor</code>、<code>ConnectInterceptor</code>、<code>CallServerInterceptor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于它们的源码实现会在后面的<strong>核心类解读</strong>中详细分析，这里先了解一个它们各自的作用：</p><ul><li><strong>RetryAndFollowUpInterceptor</strong>：用于失败时恢复以及在必要时进行重定向。</li><li><strong>BridgeInterceptor</strong>：应用代码与网络代码的桥梁。首先根据用户请求建立网络请求，然后执行这个网络请求，最后根据网络请求的响应数据建立一个用户响应数据。</li><li><strong>CacheInterceptor</strong>：用于从本地缓存中读取数据，以及将服务器数据写入到缓存。</li><li><strong>ConnectInterceptor</strong>：用于打开一个到目标服务器的连接，并切换至下一个拦截器。</li><li><strong>CallServerInterceptor</strong>：这是拦截器链的最后一环，至此将真正的进行服务器请求。</li></ul><p><strong>请求时整个拦截器的调用链的执行次序如下</strong>：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f0bc111a3f8d06f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器执行链"></p><p>对于请求时拦截器的调用链你可能会有所疑惑，为什么它是按这个次序执行的呢？咱看看<code>RealInterceptorChain#proceed(...)</code>方法的主要源码，发现，虽然这里看起来只进行了一次调用，但是如果你结合这些拦截器一起分析的话，你就会发现，其实这里对拦截器集合进行了递归取值，因为每次执行<code>proceed()</code>方法时集合索引<code>index</code>会 <code>+1</code>， 并将<code>index</code>传入新建的<code>RealInterceptorChain</code>，而拦截器集合唯一，因此相当于每次<code>proceed</code>都是依次取得拦截器链中的下一个拦截器并使用这个新建的<code>RealInterceptorChain</code>，执行<code>RealInterceptorChain#proceed</code>方法，直到集合递归读取完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 每次执行 proceed() 方法时 index+1， 然后传入新建的 RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">     <span class="comment">// 但是 拦截器集合是相同的，因此相当于每次都是依次取得拦截器链中的下一个拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归？</strong> 是的，如果你观察的够仔细的话，你会发现，其实<code>BridgeInterceptor</code>、<code>RetryAndFollowUpInterceptor</code>、<code>CacheInterceptor</code>、<code>ConnectInterceptor</code>都会执行<code>RealInterceptorChain#proceed</code>方法，相当于这个方法在不断地调用自己，符合递归的执行特性，因此<code>Response</code>响应数据的返回次序刚好是与请求时相反的。<code>BridgeInterceptor#intercept</code>相应抽取的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因而拦截器链的响应数据返回次序如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-e986fd97b4d130c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器链的响应次序"></p><p>我靠，是不是觉得设计的非常巧妙，这也是我热衷于源码的重要原因之一，因为不看看别人的代码你就永远不知道别人有多骚。。</p><p>根据上面的分析，我们已经知道了原来<strong>正真执行请求、处理响应数据是在拦截器，并且对于同步请求，分发器<code>Dispatcher</code>仅仅是记录下了同步请求的<code>Call</code>，用作请求数量统计用的，并没有参与到实际请求和执行中来。</strong></p><p>OK，来看看异步请求<code>RealCall#enqueue()</code>和<code>Dispatcher#enqueue()</code>，毫无疑问，异步请求肯定是运行在线程池中了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Dispatcher#enqueue()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的<code>AsyncCall</code>，核心源码如下，注意到<code>getResponseWithInterceptorChain()</code>，是不是非常地熟悉了，在上面的同步请求那里已经详细解释过了，就不再累赘了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>OkHttp</code>的主体运作流程是不是已经清晰了，不过有没有感觉还少点什么，我们只是分析了运作流程，具体到怎么连接的问题还没有分析。</p><p>好吧，既然是建立连接，那么极速定位到<code>ConnectInterceptor</code>，没毛病吧, 核心源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的<code>streamAllocation.newStream(..)</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">( OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      <span class="comment">// 1. 查找可用连接</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      <span class="comment">// 2. 建立 HTTP 或 HTTP2 连接</span></span><br><span class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        codec = resultCodec;</span><br><span class="line">        <span class="keyword">return</span> resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续定位到 <code>findHealthyConnection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 完全阻塞式查找，找不到不罢休</span></span><br><span class="line">      <span class="comment">// 1. 查找已有连接</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 如果这是一条全新的连接，那么可以跳过大量的健康检查，直接返回</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. 做一个速度超慢的检查，以确保池中的连接仍然可用，</span></span><br><span class="line">      <span class="comment">//    如果不可用了就将其从池中剔除，然后继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        noNewStreams();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到<code>StreamAllocation#findConnection</code>，这里<strong>查找连接的规则是：先查看当前是否存在可用连接，如果不存在，再从连接池中查找，如果还没有，那就新建一个，用来承载新的数据流。</strong> 需要注意的一个细节就是，从连接池查找连接时会查询两次，第一次只是根据当前目标服务器地址去查，如果没有查到，则第二次会重新选择路由表，然后用该地址去匹配。最终如果存在已经创建好的连接，则直接返回使用，如果不存在，则新建一个连接，进行<code>TCP</code>和<code>TLS</code>握手，完事之后将这个连接的路由信息记录在路由表中，并把这个连接保存到连接池。<strong>还需要注意的一点是：如果有个连接与当前建立的连接的地址相同，那么将释放掉当前建立好的连接，而使用后面创建的连接（保证连接是最新的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      <span class="comment">// 1. 检查当前有没有可用连接，如果有，那么直接用当前连接</span></span><br><span class="line">      releasedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">      toClose = releaseIfNoNewStreams();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123; <span class="comment">// 可用</span></span><br><span class="line">        result = <span class="keyword">this</span>.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 2. 不存在已有连接或者已有连接不可用，则尝试从连接池中获得可用连接</span></span><br><span class="line">        Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedRoute = route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123; <span class="comment">// 已有连接中找到了连接,完成任务</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 选择一条路由，这是个阻塞式操作</span></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">          <span class="comment">// 路由已经选好了，此时再根据路由中的 IP集合去匹配连接池中的连接，</span></span><br><span class="line">          <span class="comment">// 这个可能因为连接合并的缘故而匹配到</span></span><br><span class="line">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">          Route route = routes.get(i);</span><br><span class="line">          Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">          <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">            result = connection;</span><br><span class="line">            <span class="keyword">this</span>.route = route;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 最后实在没找到已有的连接，那么就只能重新建立连接了</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据路由匹配到了连接池中的连接</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 TCP + TLS 握手. 这是阻塞式操作</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    routeDatabase().connected(result.route()); <span class="comment">// 路由表中记录下这个连接的路由信息</span></span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 将这个连接记录到连接池</span></span><br><span class="line">      Internal.instance.put(connectionPool, result);</span><br><span class="line">      <span class="comment">// 如果多个连接指向当前创建的连接的相同地址，那么释放掉当前连接，使用后面创建的连接</span></span><br><span class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上分析可得出以下主体执行流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-d15b7b6118737e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OkHttp主体执行流程.png"></p><p>当然这是同步请求的流程，而对于异步请求而言，也仅仅是把拦截器链放到了线程池执行器中执行而已。</p><h3 id="三、核心类解读"><a href="#三、核心类解读" class="headerlink" title="三、核心类解读"></a>三、核心类解读</h3><p>至此，我们已经清楚了<code>OkHttp</code>的主干，当然，我们仅仅是把流程给走通了，在本节中，我们将根据源码具体分析<code>OkHttp</code>中各核心类的作用及其实现，内容很长，请做好心理准备。</p><h4 id="1-拦截器（Intercepter）"><a href="#1-拦截器（Intercepter）" class="headerlink" title="1. 拦截器（Intercepter）"></a>1. 拦截器（<code>Intercepter</code>）</h4><p><strong>1). RetryAndFollowUpInterceptor</strong></p><p>作用：用于失败时恢复以及在必要时进行重定向。</p><p>作为核心方法，<code>RetryAndFollowUpInterceptor#intercept</code>体现了<code>RetryAndFollowUpInterceptor</code>的工作流程，源码如下，我们来分析分析它是怎么恢复和重定向的，具体实现流程还请看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = chain.request();</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Call call = realChain.call();</span><br><span class="line">  EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅仅创建流的承载对象，此时并没有建立流</span></span><br><span class="line">  StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">      createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">  <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> followUpCount = <span class="number">0</span>; <span class="comment">// 用于记录重定向和需要授权请求的数量</span></span><br><span class="line">  Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果此时请求被取消了，那么关闭连接，释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123; </span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 推进执行拦截器链，请求并返回响应数据</span></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      <span class="comment">// 3. 如果连接失败了，尝试使用失败的地址恢复一下，此时请求可能还没有发送</span></span><br><span class="line">      <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">      &#125;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// 4. 尝试重新与交流失败的服务器重新交流，这个时候请求可能已经发送了</span></span><br><span class="line">      <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">      <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 5. 如果是位置异常，那么释放掉所有资源</span></span><br><span class="line">      <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">        streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 如果记录的上一个请求大的响应数据存在，那么将其响应体置空</span></span><br><span class="line">    <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(<span class="keyword">null</span>)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request followUp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 7. 处理请求的认证头部、重定向或请求超时问题，如果这些操作都不必要</span></span><br><span class="line">      <span class="comment">//    或者应用不了，那么返回 null</span></span><br><span class="line">      followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要处理认证、重定向和超时问题，那么结束处理，返回响应数据</span></span><br><span class="line">    <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，关闭当前响应，进行后续重定向等问题的处理</span></span><br><span class="line">    closeQuietly(response.body());</span><br><span class="line">    <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">          createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">      <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">          + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = followUp;</span><br><span class="line">    priorResponse = response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). BridgeInterceptor</strong></p><p>作用：应用代码与网络代码的桥梁。首先根据用户请求建立网络请求，然后执行这个网络请求，最后根据网络请求的响应数据建立一个用户响应数据。</p><p><code>BridgeInterceptor#intercept</code>源码如下，主要做了以下事情：</p><ul><li><strong>用于请求：</strong> 这个是在推进请求拦截器链时进行的，也就是说此时尚未真正地进行网络请求。此时会补充缺失的请求头参数，如 <code>Content-Type</code>、<code>Transfer-Encoding</code>、<code>Host</code>、<code>Connection</code>、<code>Accept-Encoding</code>、<code>User-Agent</code>、<code>Cookie</code>。如果在请求时添加了<code>gzip</code>请求头参数，即开启了<code>gzip</code>压缩，那么在取得响应数据时需要对数据进行解压。</li><li><strong>用于响应：</strong> 这个实在取得网络响应数据后回退拦截器链时进行的，即已经取得了网络响应数据。此时会对相应头部进行处理，如果请求时开启了<code>gzip</code>压缩，那么此时会对响应数据进行解压。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里处于请求之前</span></span><br><span class="line">  <span class="comment">// 1. 此时主要为请求添加缺失的请求头参数</span></span><br><span class="line">  RequestBody body = userRequest.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 如果启用了GZIP压缩，那么需要负责解压响应数据</span></span><br><span class="line">  <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">    requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 推进执行拦截器链，进行请求、返回数据</span></span><br><span class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得网络响应数据后</span></span><br><span class="line">  <span class="comment">// 3. 处理响应头，如果请求时开启了GZIP压缩，那么这里需要将响应数据解压</span></span><br><span class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip</span><br><span class="line">      &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">      &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">    GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">    Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">        .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">        .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">        .build();</span><br><span class="line">    responseBuilder.headers(strippedHeaders);</span><br><span class="line">    String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">    <span class="comment">// 建立用户响应数据</span></span><br><span class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，<code>BridgeInterceptor</code>主要用于请求前对用户请求进行完善，补充缺失参数，然后推进请求拦截器链，并等待响应数据返回，取得响应数据后则是将其转换成用户响应数据，此时如果数据进行过<code>gzip</code>压缩，那么会在这里进行解压，然后重新封装成用户数据。</p><p><strong>3). CacheInterceptor</strong></p><p>作用：用于从本地缓存中读取数据，以及将服务器数据写入到缓存。</p><p><code>CacheInterceptor#intercept</code>源码如下，拦截器链执行到这一步主要做了如下事情：</p><ul><li><p><strong>请求：</strong> </p><p>如果开启了缓存，且请求策略是禁用网络仅读缓存的话，那么首先会根据当前请求去查找缓存，如果匹配到了缓存，则将缓存封装成响应数据返回，如果没有匹配到，那么返回一个<code>504</code>的响应，这将导致请求拦截器链执行终止，进而返回执行响应拦截器链。</p><p>如果请求策略是网络加缓存，当那么然网络请求优先，所以就推进请求拦截器链执行请求，</p></li><li><p><strong>网络响应：</strong> </p><p>在得到网络响应数据后，如果开启了缓存策略其匹配到了旧缓存，那么根据最新网络请求响应数据更新缓存，然后返回响应数据；如果没有匹配到缓存但是开启了缓存，那么将响应数据写入缓存后返回；而如果开启了缓存，但是并不使用缓存策略，那么根据响应数据移除缓存中对应的数据缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//  读取候选的旧缓存</span></span><br><span class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 解析请求和缓存策略</span></span><br><span class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  Request networkRequest = strategy.networkRequest; <span class="comment">// 如果仅读缓存，那么网络请求会为 null</span></span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// 如果禁止使用网络而仅读取缓存的话，那么没匹配到缓存时返回 504</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果禁止使用网络而仅读取缓存的话，那么匹配到缓存时将其返回</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 推进执行请求拦截器链</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 请求异常则关闭候选缓存实体</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据最新网络请求响应数据更新缓存，然后返回响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 无匹配缓存的情况</span></span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// 使用缓存策略且无匹配缓存，则将响应数据写入缓存</span></span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// 不使用缓存策略，则删除已有缓存</span></span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>缓存时判断逻辑比较多，不过这里重点在于理解缓存策略，一般会有：<strong>仅网络</strong>、<strong>仅缓存</strong>、<strong>网络加缓存</strong> 三种请求策略。</p><p><strong>4). ConnectInterceptor</strong></p><p>作用：用于打开一个到目标服务器的连接，并切换至下一个拦截器</p><p>因为在上一节末尾分析<code>OkHttp</code>如何建立连接的问题上已经分析过了，所以不做过多描述。</p><p>这里回忆一下连接规则：建立连接时，首先会查看当前是否有可用连接，如果没有，那么会去连接池中查找，如果找到了，当然就使用这个连接，如果没有，那么就新建一个连接，进行<code>TCP</code>和<code>TLS</code>握手以建立联系，接着把连接放入连接池以备后续复用，最后推进请求拦截器链执行，将打开的连接交给下一个拦截器去处理。</p><p><strong>5). CallServerInterceptor</strong></p><p>作用：这是拦截器链的最后一环，至此将真正的进行服务器请求</p><p><code>CallServerInterceptor#intercept</code>源码如下，作为拦截器链的最后一环，当然要真正地做点实事了，大致操作步骤是：</p><p>发送请求头部 –&gt;  读取一下<code>GET</code>、<code>HEAD</code>之外的请求（如<code>POST</code>）的响应数据 –&gt; 结束请求的发送动作 –&gt; 读取响应头部 –&gt; 读取响应数据 –&gt; 封装后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 发送请求头部</span></span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 2. 检查是否是 GET 或 HEAD 以外的请求方式、读取响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果请求头部中包含"Expect: 100-continue"，那么在转换请求体前等待"HTTP/1.1 100 Continue"</span></span><br><span class="line">    <span class="comment">// 响应。如果没有读取到"HTTP/1.1 100 Continue"的响应，那么就不转换请求体(request body)了，</span></span><br><span class="line">    <span class="comment">// 而直接将我们得到的响应返回（如 状态为 4XX 的响应 ）；</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      <span class="comment">// 读取、转换响应头部</span></span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在"Expect: 100-continue"，则写入请求体</span></span><br><span class="line">      <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">          <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">      <span class="comment">// 如果不存在"Expect: 100-continue"，那么禁止 HTTP/1 连接复用。</span></span><br><span class="line">      <span class="comment">// 不过我们仍然必须转换请求体以使连接达到一个固定的状态。</span></span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 结束请求的发送动作</span></span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 读取响应头部</span></span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 构建响应数据</span></span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果服务器返回 100-continue 响应即使我们并没有这么请求，则重新读取一遍响应数据；</span></span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    response = responseBuilder</span><br><span class="line">            .request(request) </span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6. 填充响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// 连接正在更新，不过我们需要确保拦截器收到的 non-null 的响应体</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里将 http 输入流包装到响应体</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况...</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，作为拦截器最后一环的<code>CallServerInterceptor</code>终于把请求给终结了，完成了与服务器的沟通交流，把需要的数据拿了回来。请求的时候每个拦截器都会插上一脚，响应的时候也一样，把数据转换的工作分给了各个拦截器处理。</p><h4 id="2-分发器（Dispatcher）"><a href="#2-分发器（Dispatcher）" class="headerlink" title="2. 分发器（Dispatcher）"></a>2. 分发器（<code>Dispatcher</code>）</h4><p>为什么叫分发器呢？如果叫做执行器(<code>Executor</code>)可能会更好理解一些，因为它的工作就是执行异步请求，虽然会统计请求的数量….嗯~~好吧，换个角度，如果理解为它用于把异步任务分发给线程池执行，起到任务分发的作用，那就理解为啥叫分发器了。</p><p>OK，先来观察一下<code>Dispatcher</code>的构成，部分源码如下，可以先看看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;  <span class="comment">// 同时执行的最大异步请求数量，数量超过该值时，新增的请求会放入异步请求队列中</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;  <span class="comment">// 每个主机最多同时存在的请求数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 线程池执行器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line">  <span class="comment">// 尚未执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">// 正在执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">// 同步执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化线程池执行器</span></span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单描述一下：<code>Dispatcher</code>包含三个任务队列，分别用于记录尚未执行的异步请求、正在执行的异步请求、正在执行的同步请求。包含一个线程池，用于执行异步请求，这个线程池执行器的核心线程数量为 <code>0</code>， 最大线程数量不限（整型的最大值<code>2^31-1</code>，相当于不限），闲置线程的最大等待超时时间为<code>60</code>秒,线程池的任务队列使用非公平机制的<code>SynchronousQueue</code>。这就是<code>Dispatcher</code>的主要配置。</p><p>我们来看看它是如何限制每个主机的请求数量的，直接看注释好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正在执行的异步请求数量小于限定值，且同一主机的正在执行的异步请求数量小于限定值时</span></span><br><span class="line">    <span class="comment">// 添加到正在执行的异步请求队列中，并执行。</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就添加到等待队列中</span></span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>runningCallsForHost</code>用于计算当前正在执行的连接到相同主机上异步请求的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the number of running calls that share a host with &#123;<span class="doctag">@code</span> call&#125;. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runningCallsForHost</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (AsyncCall c : runningAsyncCalls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.get().forWebSocket) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (c.host().equals(call.host())) result++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-连接池（ConnetionPool）"><a href="#3-连接池（ConnetionPool）" class="headerlink" title="3. 连接池（ConnetionPool）"></a>3. 连接池（<code>ConnetionPool</code>）</h4><p>作用：用于管理<code>HTTP</code>和<code>HTTP/2</code>连接的复用以减少网络延迟，因为使用相同地址的请求可能共享一个连接。所以<code>ConnetionPool</code>实现了维护已打开连接已被后续使用的机制。</p><p>线程池啥的就不多说了，这里主要分析一下<code>ConnetionPool</code>如何维护已打开的连接。从<code>ConnetionPool#put</code>着手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123; <span class="comment">// 如果当前不在执行清理任务，那么现在执行</span></span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    executor.execute(cleanupRunnable); <span class="comment">// 线程池的作用就是执行清理任务</span></span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection); <span class="comment">// 同时添加到连接队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cleanupRunnable</code>源码如下，根据<code>ConnetionPool#put</code>可知每当我们往连接池中添加一个连接时，如果当前不在执行清理任务(<code>cleanupRunnable</code>)，那么立马会执行<code>cleanupRunnable</code>，而<code>cleanupRunnable</code>中会循环执行<code>cleanup</code>，直到所有连接都因闲置超时而被清理掉，具体还请先看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime()); <span class="comment">// 执行清理</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// cleanup中的情况 4)</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;  <span class="comment">// cleanup中的情况 2) 和 3)  </span></span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos); <span class="comment">// 等待超时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 至此情况 1), 2), 3) 都会导致 `cleanup`被循环执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>cleanup</code>源码如下，它的作用是查找、清理超过了<code>keep-alive</code>时间限制或者闲置超时闲置的连接。具体还请看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 查找超时连接</span></span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 1). 如果正在使用，那么跳过，继续查找</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++; <span class="comment">// 记录闲置连接的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2). 如果闲置时间超过了最大允许闲置时间，则记录下来在后面清除</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 查找完成了，将在这里对闲置连接进行处理</span></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// 1). 确定已经超时了，那么从连接池中清除，关闭动作会在同步块外面进行</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2). 存在闲置连接，但是尚未超时</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3). 如果所有连接都正在使用，那么最多保持个`keep-alive`超时时间就又会重新执行清理动作</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4). 压根没有连接，那不管了，标记为非清理状态，并返回-1</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭上面查找到的处于情况1)的闲置超时连接</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="comment">// 返回 0 ，表示马上会重新回来执行清理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>综上，<code>ConnectionPool</code> 会设定<code>keepAliveDurationNs</code>、<code>longestIdleDurationNs</code>两个超时时间，而每次往连接池中添加一个新连接时，如果当前处于非清理装填，都会导致线程池执行器开个线程执行清理动作，而对于清理动作而言，会遍历连接池，查找闲置超时的连接，并记录闲置连接的数量，而遍历完成后，将根据情况 1)、2)、3)、4) 进行相应的处理，而如果是情况 4)， 则会当即结束清理循环，意味着连接池中已经没有连接了，此时线程会执行完成而退出，其他几种情况都不会中断循环，因此实际上这个线程池最多只会存在一个连接池维护线程。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>一般来说，当使用<code>OKHttp</code>通过<code>URL</code>请求时，它做了以下事情：</p><ul><li>使用<code>URL</code>并且配置<code>OKHttpClient</code>来创建地址(<code>Address</code>)，这个地址指定了我们连接<code>web</code>服务器的方式。</li><li>尝试从连接池(<code>ConnectionPool</code>)中取出与该地址相同的连接。</li><li>如果在连接池中没有对应该地址的连接，那么它会选择一条新路线（<code>route</code>）去尝试，这通常意味着将进行<code>DNS</code>请求以获取对应服务器的<code>IP</code>地址，然后如果需要的话还会选择<code>TLS</code>版本和代理服务器。</li><li>如果这是一条新路线，它会通过<code>Socket</code>连、<code>TLS</code>隧道（HTTP代理的HTTPS）或者<code>TLS</code>连接，然后根据需要进行<code>TCP</code>、<code>TLS</code>握手。</li><li>发送<code>HTTP</code>请求，然后读取响应数据。</li></ul><p>如果连接出现问题，<code>OKHttp</code>会选择另一条路线再次尝试，这使得<code>OKHttp</code>在服务器地址子集无法访问时能够恢复，而当从连接池中拿到的连接已经过期，或者<code>TLS</code>版本不支持的情况下，这种方式同样很有用。一旦接收到响应数据，该连接就会返回到连接池中以备后续请求使用，而连接池中的连接也会在一定时间的不活动状态后被清除掉。</p><p>对于整体框架而言，本文已经详细分析了<code>OkHttp</code>的整体工作流程，相关细节还请回到文中去，这里就不再累赘了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 进程间通信</title>
      <link href="/2019/06/02/Android-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/06/02/Android-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>关于<code>Android</code>中的进程间通信，我们知道大概可以通过以下方式进行：</p><ul><li><code>Bundle</code>：四大组件间通信</li><li><code>File</code>：文件共享</li><li><code>ContentProvider</code>：应用间数据共享</li><li><code>AIDL</code>：<code>Binder</code>机制</li><li><code>Messager</code>：基于<code>AIDL</code>、<code>Handler</code>实现</li><li><code>Socket</code>：建立<code>C/S</code>通信模型</li></ul><p><strong>本文主要探索的是<code>AIDL</code>和<code>Socket</code>两种实现方式</strong>，并在日常使用的基础上根据<code>AIDL</code>所生成的代码分析 <code>Binder</code>跨进程通信机制，感兴趣的童鞋可以看看。</p><p>本文完整代码：<a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a></p><a id="more"></a><h3 id="二、使用-AIDL和-Socket-进行通信"><a href="#二、使用-AIDL和-Socket-进行通信" class="headerlink" title="二、使用 AIDL和 Socket 进行通信"></a>二、使用 <code>AIDL</code>和 <code>Socket</code> 进行通信</h3><p>先来说说我们一会儿要实现的通信模型，大致如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f53350287d6fac66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要实现的通信模型"></p><p>然后看看目录结构：<br><img src="https://upload-images.jianshu.io/upload_images/5879616-dc67447c3d62653d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件路径"></p><p>再看看<code>IMyAidlInterface.aidl</code>，这里在定义方法名称的时候需要注意的是<strong>方法不能同名，包需要手动导入</strong>，可能是因为<code>AIDL</code>文件在解析时不会区分参数类型，导致我在设定同名方法时一直编译错误，搞得我一直找其他问题，所以这点需要注意一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line"><span class="comment">// 需要手动导入的包</span></span><br><span class="line"><span class="keyword">import</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterfaceCallback;</span><br><span class="line"><span class="keyword">import</span> com.project.horselai.bindprogressguarddemo.MyMessage;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageObj</span><span class="params">(in MyMessage msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span><span class="params">(IMyAidlInterfaceCallback callback)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterCallback</span><span class="params">(IMyAidlInterfaceCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>IMyAidlInterfaceCallback.aidl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterfaceCallback.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterfaceCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onValueCallback</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>MyMessage.aidl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyMessage.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line"></span><br><span class="line">parcelable MyMessage;</span><br></pre></td></tr></table></figure><p>其他代码太长就不贴出来了，具体请查看 <a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a>。</p><p>演示图如下，具体还是跑起来看看吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-b48b47ff8b940623.gif?imageMogr2/auto-orient/strip" alt="演示.gif"></p><p> <img src="https://upload-images.jianshu.io/upload_images/5879616-5644504702a70c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出信息"></p><p>这里有个现象就是，<code>unbindService</code> 调用之后，<code>ServiceConnection</code> 并没有中断，因此，如果此时再次发送消息也是能够发送和接收到的。</p><h3 id="三、从AIDL生成类源码角度理解Binder机制"><a href="#三、从AIDL生成类源码角度理解Binder机制" class="headerlink" title="三、从AIDL生成类源码角度理解Binder机制"></a>三、从<code>AIDL</code>生成类源码角度理解<code>Binder</code>机制</h3><p><strong>1. 先来点关于 IBinder 的理论知识</strong></p><p>官方原文：<a href="https://developer.android.google.cn/reference/android/os/IBinder.html?hl=zh-cn" target="_blank" rel="noopener">IBinder</a></p><p><code>IBinder</code>作为远程对象的基础接口，是为高性能执行跨进程和进程内调用设计的轻量级远程调用机制的核心部分，它描述了与远程对象交互时的抽象协议，使用时应该继承 <code>Binder</code>，而应直接实现 <code>IBinder</code>接口。</p><p><code>IBinder</code>的关键 <code>API</code>是 <code>transact()</code>，它与 <code>Binder.onTranscat()</code>配对使用，当调用<code>transcat()</code>方法时会发送请求到<code>IBinder</code>对象，而接收到请求时是在<code>Binder.onTranscat()</code>中接收，<code>transcat()</code>是同步执行的，执行<code>transcat()</code>后<code>transcat()</code>会等待对方<code>Binder.onTranscat()</code>方法返回后才返回，这种行为在同一进程中执行时是必然的，而在不同进程间执行时，底层<code>IPC</code>机制也会确保具备与之相同的行为。</p><p><code>transact()</code>方法发送的是<code>Parcel</code>类型的数据，<code>Parcel</code>是一种通用数据缓冲，它包含一些描述它所承载内容的元数据(<code>meta-data</code>)，这些元数据用于管理缓冲数据中的<code>IBinder</code>对象引用，因此这些引用可以被保存为缓冲数据而传递到其他进程。这种机制保证了<code>IBinder</code>能够被写入<code>Parcel</code>中并发送到其他进程，如果其他进程发送相同的<code>IBinder</code>引用回来给源进程，则说明源进程收到一个相同的<code>IBinder</code>对象，这种特性使<code>IBinder/Binder</code>对象能够作为进程间的唯一标识（作为服务器<code>token</code>或者其他目的）。</p><p>系统会为每个运行的进程维护一个事务线程池，线程池中的线程用于分发所有来自其他进程的<code>IPC</code>事务，例如，当进程<code>A</code>与进程<code>B</code>进行<code>IPC</code>时（此时<code>A</code>为发送进程），由于<code>A</code>调用<code>transact()</code>发送事务到进程<code>B</code>的缘故，<code>A</code>中被调用的线程会被阻塞在<code>transact()</code>，此时如果<code>B</code>进程中的可用线程池线程接收到了来自<code>A</code>的事务，就会调用目标对象（<code>A</code>进程）的<code>Binder.onTranscat()</code>，并回复一个<code>Parcel</code>作为应答。接收到来自<code>B</code>进程的应答后，在<code>A</code>进程中执行<code>transact()</code>的线程就会结束阻塞，从而继续执行其他逻辑。</p><p><code>Binder</code>系统同样支持跨进程递归，例如，如果进程<code>A</code>执行一个事务到进程<code>B</code>，然后进程<code>B</code>处理接收到的事务时又执行了由进程<code>A</code>实现的<code>IBinder.transact()</code>，那么进程<code>A</code>中正在等待原事务执行结束的线程将用于执行由进程<code>B</code>调用的对象的<code>Binder.onTranscat()</code>应答。这种行为保证了递归机制在远程调用<code>Binder</code>对象和本地调用时行为一致。</p><p><strong>通过以下三种方式可以确定远程对象是否可用：</strong></p><ul><li>当调用一个不存在进程的<code>IBinder.transact()</code>时会抛出<code>RemoteException</code>异常；</li><li>调用<code>pingBinder()</code>返回<code>false</code>时表示远程进程已经不存在；</li><li>使用<code>linkToDeath()</code>方法给<code>IBinder</code>注册一个<code>IBinder.DeathRecipient</code>，那么当其承载进程被杀死时会通过这个监听器通知；</li></ul><p><strong>2. AIDL 生成类源码分析</strong></p><p>先来看看生成类的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-c4f67681c4e902e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成类的结构"></p><p>其中<code>IMyAidlInterface</code>接口是我们定义<code>AIDL</code>接口的直接代码生成，而<code>IMyAidlInterface.Stub</code>则是实现<code>IMyAidlInterface</code>接口的抽象类，实现了<code>onTranscat()</code>方法，不过它并没有具体实现<code>IMyAidlInterface</code>的方法，而是将这部分的实现交给了<code>IMyAidlInterface.Stub.Proxy</code>。</p><p>OK，我们来具体分析一下。首先定位到<code>Stub#asInterface</code>，可见它主要负责区分当前进行的是本地通信还是跨进程通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.project.horselai.bindprogressguarddemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 查找本地是否存在这个 IBinder 对象</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="comment">// 如果是本地通信，则稍后进行本地通信</span></span><br><span class="line">        <span class="keyword">return</span> ((com.project.horselai.bindprogressguarddemo.IMyAidlInterface) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 否则，稍后使用这个对象进行远程通信</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来看看<code>Stub#onTranscat</code>方法， 各参数作用如下</p><ul><li><strong>code：</strong> 标识需要执行的动作，是一个从<code>FIRST_CALL_TRANSACTION</code>到<code>LAST_CALL_TRANSACTION</code>之间的数字。</li><li><strong>data：</strong> <code>transcat()</code>调用者发送过来的数据。</li><li><strong>reply：</strong> 用于给<code>transcat()</code>调用者写入应答数据。</li><li><strong>flags：</strong> 如果是 <code>0</code>，代表是一个普通<code>RPC</code>，如果是<code>FLAG_ONEWAY</code>则代表是一个<code>one-way</code>类型的<code>RPC</code>。</li><li><strong>return：</strong> 返回<code>true</code>代表请求成功了，返回<code>false</code>则表示你没有明白事务代码（<code>code</code>）。</li></ul><p>基于前面的理论知识，我们已经知道进程<code>A</code>中的<code>onTransact()</code>会被进程<code>B</code>调用，用于远程回调应答数据，下面通过两个标志性的方法解释在<code>onTransact()</code>中都做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="comment">// 对于远程写请求</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_sendMessage: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            java.lang.String _arg0;</span><br><span class="line">            <span class="comment">// 1. 从进程A的远程请求包中读取请求数据</span></span><br><span class="line">            _arg0 = data.readString();</span><br><span class="line">            <span class="comment">// 2. 执行进程B中的sendMessage方法写入来自进程A的数据</span></span><br><span class="line">            <span class="keyword">this</span>.sendMessage(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于远程读请求</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getProcessId: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            <span class="comment">// 1. 执行进程B中的getProcessId() 读取需要作为响应数据的数据</span></span><br><span class="line">            <span class="keyword">int</span> _result = <span class="keyword">this</span>.getProcessId();</span><br><span class="line">            <span class="comment">// 2. 将读取到的响应数据写入到进程A的应答中</span></span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你会对上面的<code>this.sendMessage(_arg0)</code>和<code>this.getProcessId()</code>有所疑问，比如，为什么在<code>TRANSACTION_sendMessage</code>中还要执行<code>this.sendMessage(_arg0)</code>，这不就死循环了吗？ 不会的，为啥呢，因为<code>TRANSACTION_sendMessage</code>判断的是来自进程<code>A</code>的方法类型码，而在解析了来自进程<code>A</code>的请求参数<code>data</code>后会调用进程<code>B</code>自身的<code>sendMessage(_arg0)</code>方法将数据保存到自己的存储内存中，而它的<code>sendMessage(_arg0)</code>是有我们自己实现的，如下是我们在进程<code>B</code>中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMyAidlInterface.Stub myAidlInterface = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"sendMessage: "</span> + msg);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.myPid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这是不是就很好理解了。</p><p>下面通过<code>Proxy#sendMessage</code>和<code>Proxy#getProcessId</code>两个与上面对应的方法来解释作为客户端的进程<code>A</code>是如何给远程作为服务端的<code>B</code>进程发送请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(java.lang.String msg)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); <span class="comment">// 请求参数</span></span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); <span class="comment">// 响应数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 封装远程请求参数</span></span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(msg);</span><br><span class="line">        <span class="comment">// 2. 通过Binder执行远程请求，最终响应数据会封装在_reply</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3. 没有需要返回数据则仅读取异常</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); <span class="comment">// 请求参数</span></span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); <span class="comment">// 响应数据</span></span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 没有参数，则仅写入标识</span></span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">// 2. 通过Binder执行远程请求，最终响应数据会封装在_reply</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getProcessId, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3. transact阻塞结束后读取响应数据</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，实际上<code>_reply</code>一直使用的都是同一个，由进程<code>A</code>创建，发送给<code>B</code>进程，进程<code>B</code>会将处理好的响应数据写入到<code>_reply</code>中，并最终通过<code>onTranscat</code>方法回调给进程<code>A</code>，这样就完成了一个<code>RPC</code>。</p><p>总的来说，整个过程的执行流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/5879616-c1e546e703174f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Binder进行IPC"></p><h3 id="四、Messenger使用与源码分析"><a href="#四、Messenger使用与源码分析" class="headerlink" title="四、Messenger使用与源码分析"></a>四、<code>Messenger</code>使用与源码分析</h3><p><strong>1. 使用</strong></p><p>在<code>Service</code>进程中如下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerRemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerRemoteService"</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用 Messenger 进行进程间通信</span></span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"handleMessage: "</span> + msg);</span><br><span class="line">                Log.i(TAG, <span class="string">"handleMessage data: "</span> + msg.getData().get(<span class="string">"msg"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>Activity</code>中如下建立服务连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Messenger</span></span><br><span class="line"><span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">ServiceConnection mServiceConnection3 = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onServiceConnected3: "</span>);</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        btnBindRemote.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mIsBond = <span class="keyword">true</span>;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"service bond 3!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onServiceDisconnected 3: "</span>);</span><br><span class="line">        mIsBond = <span class="keyword">false</span>;</span><br><span class="line">        btnBindRemote.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>绑定后如下发送信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>)&#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    bundle.putString(<span class="string">"msg"</span>,<span class="string">"message  clicked from Main .."</span>);</span><br><span class="line">    message.what = <span class="number">122</span>;</span><br><span class="line">    message.setData(bundle);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMessenger.send( message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-560c9a9e1d25a1c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出"></p><p>基于上面的使用，整个流程下来你会发现<code>Messenger</code>的通信是单向的，如果想要双向的话，那么需要在作为客户端的进程<code>A</code>上也创建一个<code>Messenger</code>和<code>Handler</code>，然后在<code>B</code>进程中发送响应消息。</p><p>为了能够进行双向通信，我们可以对上面代码进行如下修改，其中<code>MessengerRemoteService</code>中的<code>Messenger</code>可以这么修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"handleMessage: "</span> + msg);</span><br><span class="line">        Log.i(TAG, <span class="string">"handleMessage data: "</span> + msg.getData().get(<span class="string">"msg"</span>));</span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.replyTo = mMessenger;</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">"msg"</span>, <span class="string">"MSG from MessengerRemoteService.."</span>);</span><br><span class="line">        message.setData(bundle);</span><br><span class="line">        message.what = <span class="number">124</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注意这里</span></span><br><span class="line">            msg.replyTo.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>注意到上面的<code>msg.replyTo.send(message)</code>，其中<code>msg.replyTo</code>是一个代表发送这个消息的<code>Messenger</code>。在<code>Activity</code>中可以这么改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onCreate中</span></span><br><span class="line">mClientMessenger = <span class="keyword">new</span> Messenger(mHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper(), <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">2</span>) &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">""</span> + msg.obj, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg.what == <span class="number">124</span>)&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,   msg.getData().getString(<span class="string">"msg"</span>), Toast.LENGTH_SHORT).show();</span><br><span class="line">            Log.i(TAG, <span class="string">"handleMessage: "</span> + msg.getData().getString(<span class="string">"msg"</span>));</span><br><span class="line">            Log.i(TAG, <span class="string">"handleMessage: "</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setText(String.valueOf(msg.obj));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后<code>Activity</code>收到消息时会弹出收到的消息，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-d6b681bc8d4ef7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收到MessengerRemoteService消息"></p><p>整个双向通信的流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f120f2f156a75086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Messenger双向通信"></p><p><strong>2. Messenger 实现原理</strong></p><p>Messenger底层仅仅是简单地包裹了一下<code>Binder</code>，具体来说就是也使用的<code>AIDL</code>，因此它不会影响到进程的生命周期，不过当进程销毁时，连接也会中断。</p><p>下面来简要看一下它的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">        mTarget = target.getIMessenger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">        mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>IMessenger</code>是个<code>AIDL</code>接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os; </span><br><span class="line"><span class="keyword">import</span> android.os.Message; </span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的知识基础，这玩意儿就很好理解了。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>本文主要描述了<code>Android</code>进程间通信中的<code>AIDL</code>和<code>Socket</code>两种方式，文中没有对<code>Socket</code>方式做过多描述和分析，是因为使用<code>Socket</code>通信是比较基础的事情，并且它的实现过程相对容易理解，因此就一笔带过了，具体实现源码请查看 <a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a>。文中着重从<code>AIDL</code>生成源码角度分析了<code>Binder</code>的运行机制，并简单介绍了<code>Messenger</code>的使用及其实现。</p><p>OK，水平有限，欢迎理性指正。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
