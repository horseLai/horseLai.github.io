<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Retrofit 源码分析</title>
      <link href="/2019/06/02/Retrofit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/Retrofit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p><code>Retrofit</code>和 <code>OKHttp</code>同为 <code>square</code> 出品的网络请求相关库，不同的是 <code>Retrofit</code>本身不进行网络请求，而是作为一个协调者，协调其他组件共同处理网络请求。用官网描述来说就是：<code>Retrofit</code>是可插拔的，它允许不同的执行机制和类库用于执行<code>HTTP</code>请求、允许不同序列化的类库进行<code>java</code>实体类与<code>HTTP</code>响应数据之间转换。</p><p><code>Retrofit</code>的网络请求部分默认基于<code>OkHttp</code>，关于<code>OkHttp</code>，鄙人写过 <a href="https://www.jianshu.com/p/ac5bc7698553" target="_blank" rel="noopener"><code>OkHttp源码分析</code></a>一文，感兴趣的童鞋可以看看。</p><p>本文纯属基于个人理解，源码解析不限于执行流程，因此受限于知识水平，有些地方可能依然没有理解到位，还请发现问题的童鞋理性指出。</p><a id="more"></a><blockquote><p><strong>温馨提示：本文源码基于 <code>Retrofit-2.4.0</code></strong></p></blockquote><h3 id="二、流程分析"><a href="#二、流程分析" class="headerlink" title="二、流程分析"></a>二、流程分析</h3><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h4><p>这里以请求 <a href="http://wanandroid.com" target="_blank" rel="noopener">玩Android</a> 首页数据为例，演示使用<code>Retrofit</code>进行网络请求的最基本方式。</p><p>首先如下初始化 <code>Retrofit</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeRetrofit</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .baseUrl(<span class="string">"http://wanandroid.com"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如下建立请求接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;page&#125;/json"</span>)</span><br><span class="line">    <span class="keyword">public</span> Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; getHomeList(<span class="meta">@Path</span>(<span class="string">"page"</span>)<span class="keyword">int</span> page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着如下调用请求、处理响应数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHomeList</span><span class="params">(<span class="keyword">int</span> page, ResCallback&lt;ResponseEntry&lt;ResponseData&gt;&gt; callback)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>)</span><br><span class="line">        service = retrofit.create(Service.class);</span><br><span class="line">    service.getHomeList(page).enqueue(<span class="keyword">new</span> Callback&lt;ResponseEntry&lt;ResponseData&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; call, Response&lt;ResponseEntry&lt;ResponseData&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">                System.out.println(response.message());</span><br><span class="line">                System.out.println(response.code());</span><br><span class="line">                System.out.println(response.headers());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                    ResponseEntry&lt;ResponseData&gt; body = response.body();</span><br><span class="line">                    <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        callback.onFailed(<span class="keyword">new</span> Exception(<span class="string">"body is null !!"</span>));</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    callback.onSuccess(body);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">上面可以注意到的一点是，不同于直接使用`OkHttp`，这里`response.body()`可以直接拿到我们需要的解析好的`Java`实体类了，而不需要再做`Json`数据解析工作， 它的使用过程如下：</span><br><span class="line"></span><br><span class="line">![Retrofit使用过程](https:<span class="comment">//upload-images.jianshu.io/upload_images/5879616-a5898157d2d31694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">而一般来说，我们使用`OkHttp`进行网络请求的使用过程如下：</span><br><span class="line"></span><br><span class="line">![一般OkHttp使用过程](https:<span class="comment">//upload-images.jianshu.io/upload_images/5879616-791301aa8a1c3917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">显然 `Retrofit` 的目的就是把网络请求、响应数据解析等相互分离的操作都整合到一起，达到 `All in one` 的效果，而实际请求和解析都是以可插拔的插件形式存在，灵活度非常高。</span><br><span class="line"></span><br><span class="line">#### 2. 创建服务到建立`Call`过程分析</span><br><span class="line"></span><br><span class="line">关于 **`Retrofit`的构建** ，我们注意一下必填参数以及默认参数即可，根据如下`Retrofit.Build#build`源码可知：</span><br><span class="line">- `baseUrl`必填</span><br><span class="line">- 默认`callFactory`为`OkHttpClient`；默认`callbackExecutor`（回调执行器）在`Android`中是主线程的`Handler`；默认会先添加`Retrofit`内部的转换器，然后是其他，比如我们自定义的转换器，这是为了避免内部转换器的行为被复写掉，以及确保使用消耗(`consume`)所有类型的转换器时能有正确的行为。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// baseUrl必填</span></span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认Call工厂为 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认回调执行器为主线程Handler</span></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125; </span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"> </span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize()); </span><br><span class="line">    <span class="comment">// 这里会先添加Retrofit内部的转换器再添加我们自定的转换器</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">    converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关注一下<code>Android</code> 平台的回调执行器，因为回调执行在主线程的<code>Handler</code>上，因此可以在回调中直接操作<code>UI</code>控件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="comment">// UI线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来分析一下<strong>使用<code>Retrofit#create</code>创建一个请求服务实例时发生了什么</strong>，<code>Retrofit#create</code>源码如下，可知：</p><ul><li><p>首先需要确定的是<code>service</code>本身是个接口，并且不继承于其他接口。</p></li><li><p>然后重点来了，<code>eagerlyValidateMethods</code>会通过反射获取<code>service</code>接口中所有的方法，接着尝试从<code>ServiceMethod</code>缓存池中查找对应于各个方法的<code>ServiceMethod</code>，如果没找到的话，则重新通过<code>ServiceMethod.parseAnnotations</code>去解析各个方法的注解，解析完成后将返回的<code>ServiceMethod</code>（这里返回的<code>ServiceMethod</code>其实是实现类<code>HttpServiceMethod</code>，<code>HttpServiceMethod</code>会负责根据解析的注解参数创建<code>Call</code>，并在<code>HttpServiceMethod#invoke</code>调用时执行网络请求）存入缓存池中，方便后续复用，这里缓存池的作用跟线程池的概念异曲同工，都是为了减少因为每次都解析（创建）而造成的不必要的性能损耗，所以干脆花点内存存起来省事儿。<code>eagerlyValidateMethods</code>执行过程如下：</p><p>  <img src="https://upload-images.jianshu.io/upload_images/5879616-d7c53603bc4a38ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eagerlyValidateMethods执行过程"></p></li><li><p>接着通过<code>Proxy.newProxyInstance</code>给服务接口创建一个代理实例，实际可转成对应接口的类型，这里主要关注一下<code>InvocationHandler</code>, 每个<code>Proxy</code>对象实例都会绑定一个<code>InvocationHandler</code>对象，当执行<code>Proxy#invok</code>方法时，最终对派发给<code>InvocationHandler#invok</code>，也就是说，我们通过服务接口实例调用接口方法时，最终都会通过<code>InvocationHandler#invok</code>去执行。<code>invoke</code>方法执行链如下：</p><p>  <img src="https://upload-images.jianshu.io/upload_images/5879616-d7709fd1103cbc27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invoke执行链"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation. </span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里实际最终执行的是 HttpServiceMethod#invoke(..)</span></span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 7.0 以前版本都是 false，Android 7.0 及以上则根据 `isDefaultMethod`的复写值决定</span></span><br><span class="line">      <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; </span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">        <span class="comment">// 先从服务方法缓存中获取</span></span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此前没有解析，则重新解析注解</span></span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        <span class="comment">// 然后将解析结果添加到缓存，以便后续复用</span></span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>parseAnnotations</code> 执行链如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-4738f224f51b738d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseAnnotations执行链"></p><p>我们顺着这条链看看，首先是<code>ServiceMethod#parseAnnotations</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 解析方法的注解参数，保存在 RequestFactory</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 2. 使用将上面解析的参数建立Call，用于网络请求</span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是<code>RequestFactory#parseAnnotations</code>，源码如下，主要做了三件事情，看注释即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 解析每个方法的注解</span></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="comment">// 2. 解析方法参数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 3. 创建 RequestFactory 保存参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接着是 `HttpServiceMethod#parseAnnotations`，源码如下：</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取 Call 适配器</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 2. 获取响应数据转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    <span class="comment">// 3. 根据解析的参数创建 HttpServiceMethod</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpServiceMethod#invok</code>执行时源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 OkHttpCall, 用于进行网络请求和响应数据转换</span></span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">      <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，便是一个服务接口从解析到创建成一个<code>OkHttp#Call</code>的过程，纵观全局，其实这个过程就好比一个为了将如下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"article/list/&#123;page&#125;/json"</span>)</span><br><span class="line">    <span class="keyword">public</span> Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; getHomeList(<span class="meta">@Path</span>(<span class="string">"page"</span>)<span class="keyword">int</span> page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析成一个请求链接为<code>http://wanandroid.com/article/list/0/json</code>，请求方式为 <code>GET</code>，请求的调用方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Service service = ...;</span><br><span class="line"><span class="comment">// 相当于执行 HttpServiceMethod#invoke 方法</span></span><br><span class="line">Call&lt;ResponseEntry&lt;ResponseData&gt;&gt; = service.getHomeList(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>的过程，而这个过程中需要解决将接口转换成对象实例、将方法注解、参数解析处理拼接为请求连接、最后确定返回类型的问题，此时<code>Call</code>尚未进行请求；</p><p><strong>3. <code>Call</code>请求执行到响应数据回调过程分析</strong></p><p>关于<code>OkHttp#Call</code>如何运作的问题已经在 <a href="https://www.jianshu.com/p/ac5bc7698553" target="_blank" rel="noopener">OkHttp源码解析</a> 一文中做了详细分析，这里的不同之处在于，在<code>Retrofit</code>中我们需要更多地关注它是如何协调请求和响应，最终回调给<code>UI</code>线程的。</p><p>OK，从<code>HttpServiceMethod#invoke</code>出发，根据前面的内容中我们已经知道它会通过<code>callAdapter.adapt(new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter))</code>返回一个<code>Call</code>实例，并且在<code>Android</code>平台上会将响应数据回调在<code>UI</code>线程的<code>Handler</code>上，因此我们先关注一下<code>Android</code>平台下的默认<code>CallAdapter</code>，于是定位到<code>Android#defaultCallAdapterFactories</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">    <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    <span class="keyword">return</span> singletonList(<span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见<code>Android</code>平台下的默认<code>CallAdapter</code>是<code>ExecutorCallAdapterFactory</code>, 于是可以定位到<code>ExecutorCallAdapterFactory#adapt</code>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorCallbackCall</code>这里实际是使用了装饰器模式，它将工作委托给了<code>callbackExecutor</code>和<code>delegate</code>，而它自身仅仅起到了协调作用，将响应数据回调到<code>UI</code>线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">   <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">     <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">     <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">     checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line">     delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 回调至主线程</span></span><br><span class="line">         callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (delegate.isCanceled()) &#123; </span><br><span class="line">               callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;   <span class="comment">// ...</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;   <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>具体到网络请求的执行与响应数据的转换工作还得看<code>OkHttpCall</code>，这里我们只关注一下<code>OKHttpCall#enqueue</code>即可， 可见这里除了请求网络数据外，还会先转换响应数据后再回调给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line">    <span class="comment">// 1. 执行请求</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 解析响应数据，将网络响应数据转换成指定数据类型</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 将解析完成的数据回调给上一级</span></span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// ... </span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后`parseResponse`部分源码如下，可见这里会通过`Converter`网络响应数据转换为我们指定的数据类型：</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line">  <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body(); </span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过转换器转换数据 </span></span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>综上可知，最终网络请求会在<code>OkHttpCall</code>中执行，获取响应数据后通过设定的<code>Converter</code>转换器将数据转换成指定类型；而最终回调给<code>UI</code>线程则是在<code>ExecutorCallbackCall</code>中进行，作为装饰器，它实际将请求和响应数据处理工作都委托给了<code>OkHttpCall</code>，而自身仅仅做了最终数据的回调处理。</p><p>于是整体执行流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-e090d2faa34a455a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体执行流程"></p><h3 id="三、Proxy"><a href="#三、Proxy" class="headerlink" title="三、Proxy"></a>三、Proxy</h3><p>这里指的是反射工具类中的<code>java.lang.reflect.Proxy</code>，通过前面的分析，我们已经知道，我们建立的服务接口会通过<code>Proxy.newProxyInstance</code>来实例化一个代理对象实例，而通过这个实例化的对象，就能像使用普通类对象实例一个调用方法。</p><p><strong>这里我比较好奇的是它是如何给接口实例化的</strong>，因此咱就来研究研究，定位到<code>Proxy#newProxyInstance</code>，精简一下源码（去除了验证逻辑等），如下，可以发现<code>Proxy</code>会为我们的服务接口构建一个代理类（当然会先从代理类缓存,也就是<code>WeakCache</code>中查找已经构建的代理类），然后通过这个类的构造函数构建出一个实例对象出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone(); </span><br><span class="line">    <span class="comment">// 1. 从 `WeakCache`中查找，或者创建一个接口的代理类 </span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">// 2. 拿到代理类的构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">    <span class="keyword">final</span> InvocationHandler ih = h; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3. 通过构造函数创建一个实例对象</span></span><br><span class="line">    <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>getProxyClass0()</code>, 根据代码注释可知，如果根据类加载器查找已经实现的代理类，那么直接返回拷贝的缓存，如果没找到，那么就会通过<code>ProxyClassFactory</code>去创建一个代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是再来看看<code>ProxyClassFactory</code>，可知通过其<code>apply</code>方法会根据我们服务接口的信息配置代理类，然后通过<code>ProxyGenerator</code>生成一个代理类<code>class</code>文件，最终通过<code>defineClass0</code>将这个代理类定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">        <span class="comment">// 1. 进行一系列的代理类信息的配置</span></span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">        <span class="comment">// 2. 根据配置信息生成代理类class文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="comment">// 3. 最终生成特定代理类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>defineClass0</code>是个<code>native</code>方法，因此就不再深挖了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(ClassLoader loader, String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure><p>至此，是不是已经明白了<code>Proxy</code>如何实例化接口的呢？</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>通过上面的分析，可以发现 <code>Retrofit</code> 更像是对一个<code>OkHttp</code>请求的抽取与封装：</p><ul><li>网络请求参数全部抽离成服务接口方法的注解，注解参数解析和<code>Request</code>构建工作抽离到了<code>RequestFactory</code>。</li><li><code>CallAdapter</code>将<code>OkHttpCall</code>的执行匹配到我们指定的执行器，而<code>Converter</code>则将网络响应数据转换成我们想要的类型</li><li>最终，在<code>Android</code>平台上直接将指定的数据类型返回给<code>UI</code>线程的<code>Handler</code>处理。</li></ul><p>关于<code>Proxy</code>，它将服务接口转换成一个代理类对象实例的实现方式也很值得我们学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 第三方库源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SparseArray与ArrayMap源码分析与总结</title>
      <link href="/2019/06/02/SparseArray%E4%B8%8EArrayMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/02/SparseArray%E4%B8%8EArrayMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li><code>SparseArray</code>是在<code>API level 1</code>就已经添加的适用于<code>Android</code>的集合类，而<code>ArrayMap</code>实在<code>API level 19</code>才加入的集合类，虽说这两者实在不同时期加入的，但是它们的目的只有一个，那就是在小数据量的情况下尽可能权衡内存占用以及使用效率，从而达到小数据量时能够替换<code>JDK</code>中类似于<code>HashMap</code>之类的集合类模板。</li><li>由于两者源码实际上存在很多相似之处，因此就放一起看了，源码还是比较容易理解的。</li></ul><h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p><code>SparseArray</code>的数据构造可以从下面这几行代码得知，显然是<strong>使用两个数组分别存储<code>key</code>和<code>value</code>的值，而这两者又因元素索引存在对应关系而刚好形成元素间的相互映射</strong>，可以说是很简单粗暴又有效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;   </span><br><span class="line">    <span class="keyword">private</span> Object[] mValues;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSize;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>put方法</strong>：揭露核心的方法</p><p>通过源码可以看出，<code>SparseArray</code>使用的是二分查找法来查找key所在的位置索引，如果存在则替换掉对应索引上的value，如果不存在，则将在索引取反后的位置上添加元素，这点跟<code>JDK</code>中的<code>Map</code>是一样的行为，存在则覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找算法 找到 key，也就是索引位置</span></span><br><span class="line">        <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123; <span class="comment">// 存在</span></span><br><span class="line">            mValues[i] = value; <span class="comment">// value数组中找到key位置上的value</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在</span></span><br><span class="line">            i = ~i; </span><br><span class="line">            <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">                mKeys[i] = key;</span><br><span class="line">                mValues[i] = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;<span class="comment">//可能value元素已经被删除了</span></span><br><span class="line">                gc();  <span class="comment">// 那么chufa一次gc</span></span><br><span class="line">                <span class="comment">// 中心搜索一遍</span></span><br><span class="line">                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">            mSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">这里的`gc`并非`JVM`中的那个`GC`，而是说当我们删除了某个元素之后，被删除元素所占用的那个位置上的数据就标记成了垃圾数据，然后就会通过`gc`来去除这个位置上的元素，而本质上，对于数组而言，就是挪动位置覆盖掉这个位置咯。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i]; </span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123; </span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;  <span class="comment">// 相当于把key、value元素都向前挪动一次</span></span><br><span class="line">                keys[o] = keys[i];  </span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>mGarbage</code>会在删除元素时被设置为<code>true</code>，也就是说标记这个位置上的元素为垃圾数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SparseArray-综述"><a href="#SparseArray-综述" class="headerlink" title="SparseArray 综述"></a>SparseArray 综述</h3><ul><li><strong>特点</strong>：使用<code>int</code>数组作为<code>map</code>的<code>key</code>容器，<code>Object</code>数组作为<code>value</code>容器，使用索引对应的形式组成<code>key-value</code>这使得<code>SparseArray</code><strong>可以不按照像数组索引那样的顺序来添加元素</strong>。可看成增强型的数组或者<code>ArrayList</code>。</li><li><strong>查找</strong>：使用<strong>二分查找法</strong>查找<code>key</code>在数组中的位置,然后根据这个数组位置得到对应<code>value</code>数组中的<code>value</code>值。</li><li><strong>优劣</strong>：相对于<code>HashMap</code>，合理使用<code>SparseArray</code>可以节省大量创建<code>Entry</code>节点时产生的内存，提高性能，但是因为基于数组，插入和删除操作需要挪动数组，非常消耗性能,而当<strong>数据有几百条时，性能会比HashMap低近50%，因此<code>SparseArray</code>适用于数据量很小的场景</strong>。</li><li><strong>使用场景举例</strong>：<ul><li><strong>通过<code>View id</code>来映射<code>View</code>对象实例</strong>。  一个非常现实的场景是，当我们使用<code>RecyclerView</code>时，我们可能需要创建若干个<code>ViewHolder</code>，特别是如果一个列表包含若干中布局类型的时候，而如果我们不适用类似于<code>ButterKnife</code>或<code>DataBinding</code>这类工具的话，那么我们需要对每个<code>控件</code>进行<code>findViewById</code>，这是件很糟心的事情，那么我们可以怎么简化呢？欸，这种情况可以使用<code>SparseArray</code>来缓存一下我们的<code>View</code>（实际上<code>ArrayMap</code>、<code>HashMap</code>等也可以）,比方说以下示例代码：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt;View&gt; mViewCache;</span><br><span class="line">    <span class="keyword">private</span> Object tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommViewHolder</span><span class="params">(@NonNull View itemView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        mViewCache = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">getView</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        T t = (T) mViewCache.get(id);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = itemView.findViewById(id);</span><br><span class="line">            mViewCache.put(id, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mViewCache.clear();</span><br><span class="line">        mViewCache = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTag</span><span class="params">(Object tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这个通用的<code>ViewHolder</code>，我们就可以应用于任意的布局类型，而不用每个都去写一个对应的<code>ViewHolder</code>了，可以说很方便了。</p><hr><h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>通过阅读<code>ArrayMap</code>的源码可以发现，它和<code>SparseArray</code>简直就是亲生兄弟啊，不同点就是，<code>ArrayMap</code>具备完整的<code>Map</code>特性，因为继承自<code>Map</code>，并且具备哈希表的相关特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mIdentityHashCode;</span><br><span class="line">    <span class="keyword">int</span>[] mHashes; <span class="comment">// 存储哈希值</span></span><br><span class="line">    Object[] mArray; <span class="comment">// 存储元素</span></span><br><span class="line">    <span class="keyword">int</span> mSize;</span><br><span class="line">    MapCollections&lt;K, V&gt; mCollections; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看看查找索引<code>index</code>源码，可以看到想要得到<code>index</code>，需要先使用二分查找法去<code>mHashs</code>数组中找出这个<code>hash</code>在数组中的位置，而这个位置就是<code>index</code>。这里就必然存在几种情况，具体可以看下面的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用二分查找算法搜索元素位置</span></span><br><span class="line">    <span class="keyword">int</span> index = binarySearchHashes(mHashes, N, hash);</span><br><span class="line">    <span class="comment">// 1. 不存在相关该hash </span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 存在该hash，且对应位置上有对应key</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 3. 存在该hash，但是对应位置上无对应key, 也就是说冲突了</span></span><br><span class="line">    <span class="comment">// 那么先搜索后半部分，之所以分成两半来查找是为了缩小查询范围，提升搜索速度</span></span><br><span class="line">    <span class="comment">// 这实际实在赌博，赌目标值在数组后半段 ，最终能否提升速度就看是不是在数组后半段了</span></span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再搜索前半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 对应key实在没找到，说明确实是冲突了，那么返回个mHashes数组大小的取反值（负数）</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的分析过程，我们已经了解了<code>ArrayMap</code>的<code>index</code>是如何决定的了，那么通过<code>put</code>方法就可以比较直观地看出<code>ArrayMap</code>的存储过程了，<strong>首先会计算我们给定<code>key</code>的哈希值，然后通过这个哈希值去查找<code>index</code>，如果在这个<code>index</code>上已经元素，那么替换这个元素，如果不存在，那么将数据存入数组中；如果存在冲突，则校检一下数组容量（看看需不需要扩容），然后存入数组</strong>。</p><pre><code class="java"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{    <span class="keyword">final</span> <span class="keyword">int</span> osize = mSize;    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="keyword">int</span> index;    <span class="comment">// 1. 查找hash，计算index</span>    <span class="keyword">if</span> (key == <span class="keyword">null</span>) {        hash = <span class="number">0</span>;        index = indexOfNull();    } <span class="keyword">else</span> {        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();        index = indexOf(key, hash);    }    <span class="comment">// 2. 根据index存值</span>    <span class="comment">// 存在，则覆盖掉旧元素，并返回旧元素</span>    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;        <span class="keyword">final</span> V old = (V)mArray[index];        mArray[index] = value;        <span class="keyword">return</span> old;    }    <span class="comment">// 有冲突的情况 </span>    index = ~index;     <span class="comment">// 数组可用空间不够，那么扩容</span>    <span class="keyword">if</span> (osize &gt;= mHashes.length) {         <span class="keyword">final</span> <span class="keyword">int</span> n = osize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (osize+(osize&gt;&gt;<span class="number">1</span>))                : (osize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);         <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;        <span class="keyword">final</span> Object[] oarray = mArray;        allocArrays(n); <span class="comment">// 扩容</span>        <span class="comment">// ...  </span>        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) { <span class="comment">// 转移元素到新数组</span>            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);        }         freeArrays(ohashes, oarray, osize); <span class="comment">// 清理就数组</span>    }    <span class="comment">// 3. 存值</span>    <span class="keyword">if</span> (index &lt; osize) {         System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, osize - index);        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);    }      mHashes[index] = hash;     <span class="comment">// key和value存在同一个数组上</span>    mArray[index&lt;&lt;<span class="number">1</span>] = key;      mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;    mSize++;    <span class="keyword">return</span> <span class="keyword">null</span>;}</code></pre><p>上面有个比较新颖的地方，就是它把<code>key</code>和<code>value</code>都存到了一个数组中去了，也就是<code>mArray</code>数组，<code>key</code>在前,<code>value</code>在后，同 <code>index</code>的关系如下图： </p><p> <img src="https://upload-images.jianshu.io/upload_images/5879616-fdd7ad9f7fd2f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mArray数组的存储结构"></p><h3 id="ArrayMap-综述"><a href="#ArrayMap-综述" class="headerlink" title="ArrayMap 综述"></a>ArrayMap 综述</h3><ul><li><p><strong>特点</strong></p><ul><li><p>实现了<code>Map</code>接口，并使用<code>int[]</code>数来存储<code>key</code>的<code>hash</code>值，数组的索引用作<code>index</code>，而使用<code>Object[]</code>数组来存储<code>key&lt;-&gt;value</code> ，这还是比较新颖的 。</p></li><li><p>使用二分查找查找<code>hash</code>值在<code>key</code>数组中的位置，然后根据这个位置得到<code>value</code>数组中对应位置的元素。</p></li><li><p>和<code>SparseArray</code>类似，当<strong>数据有几百条时，性能会比HashMap低50%，因此<code>ArrayMap</code>适用于数据量很小的场景</strong></p></li></ul></li><li><p><strong>ArrayMap和HashMap的区别？</strong></p><pre><code>- **ArrayMap的存在是为了解决HashMap占用内存大的问题，它内部使用了一个int数组用来存储元素的hashcode，使用了一个Object数组用来存储元素**，两者根据索引对应形成key-value结构，这样就不用像HashMap那样需要额外的创建Entry对象来存储，减少了内存占用。但是在数据量比较大时，ArrayMap的性能就会远低于HashMap，因为 **ArrayMap基于二分查找算法来查找元素的**，并且数组的插入操作如果不是末尾的话需要挪动数组元素，效率较低。</code></pre><ul><li><strong>而HashMap内部基于数组+单向链表+红黑树实现，也是key-value结构</strong>， 正如刚才提到的，HashMap每put一个元素都需要创建一个Entry来存放元素，导致它的内存占用会比较大，但是在大数据量的时候，因为HashMap中当出现冲突时，冲突的数据量大于8，就会从单向链表转换成红黑树，<strong>而红黑树的插入、删除、查找的时间复杂度为O(logn),相对于ArrayMap的数组而言在插入和删除操作上要快不少</strong>，所以数据量上百的情况下，使用HashMap会有更高的效率。</li></ul></li><li><p><strong>如何解决冲突问题？</strong> 在<code>ArrayMap</code>中，假设存在冲突的话，并不会像<code>HashMap</code>那样使用单向链表或红黑树来保留这些冲突的元素，而是全部<code>key</code>、<code>value</code>都存储到一个数组当中，然后查找的话通过二分查找进行，这也就是当数据量大时不宜用<code>ArrayMap</code>的原因了。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LruCache 与 LinkedHashMap</title>
      <link href="/2019/06/02/LruCache-%E4%B8%8E-LinkedHashMap/"/>
      <url>/2019/06/02/LruCache-%E4%B8%8E-LinkedHashMap/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>关于 <code>LruCache</code> 的总结，因为工作推迟了好长一段时间，因此趁现在有点空赶紧记录下来。</p><p>相信很多童鞋也跟我一样，最初都是使用 <code>LruCache</code> 作为 <code>ImageLoader</code> 图片缓存中的一环，但是使用的过程中，我们并不关心它这个“最近使用原则”到底源码怎么实现的，而仅仅在意它具备这样的特性。因此，本文要做的工作如下：</p><ul><li>从基本使用解释”最近使用“这一特性；</li><li>结合源码分析”最近使用“的实现；</li></ul><a id="more"></a><h3 id="二、从使用到源码"><a href="#二、从使用到源码" class="headerlink" title="二、从使用到源码"></a>二、从使用到源码</h3><p>首先来说说“最近使用”的特点：<strong>假设头部为最近的地方，而尾部是最远的地方，那么最先插入的元素会放到尾部，而最后插入的元素会被放到头部，并且如果我们使用了其中的某个元素，那么这个元素会被放到头部；如果容量到达了限定值，那么再次插入元素的时候就会删除掉尾部使用频率最低的元素以插入新元素</strong>。 这一特性可解释如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-ef62973bf4cd5eb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LRU使用特性"></p><p>通常我们会这样使用 <code>LruCache</code>，假定限制内存大小为 <code>5M</code>，那么可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>;</span><br><span class="line">LruCache&lt;String, Bitmap&gt; lruCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(maxSize)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, String key, Bitmap oldValue,Bitmap newValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果在列表请求时这样实现，那么快速滑动时肯定会造成内存抖动，因此实际使用中</span></span><br><span class="line">        <span class="comment">// 可以先将这些需要清理掉的图片缓存一下，然后在某个时间节点上集中清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (!oldValue.isRecycled())&#123;</span><br><span class="line">            oldValue.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跟进到它的构造方法，可以看到它创建了一个 <code>LinkedHashMap</code> ，并且仅仅是基于这一数据结构来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来验证一下前面的描述的 “最近使用” 特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap= <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">linkedHashMap.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">linkedHashMap.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">linkedHashMap.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">linkedHashMap.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">linkedHashMap.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : linkedHashMap.entrySet())&#123;</span><br><span class="line">    Log.i(TAG, e.getKey() + <span class="string">" &lt;-&gt;"</span> + e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里模拟先后使用 4 和 3 这两个元素</span></span><br><span class="line">linkedHashMap.get(<span class="number">4</span>);</span><br><span class="line">linkedHashMap.get(<span class="number">3</span>);</span><br><span class="line">Log.i(TAG, <span class="string">"-----------------"</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : linkedHashMap.entrySet())&#123;</span><br><span class="line">    Log.i(TAG, e.getKey() + <span class="string">" &lt;-&gt;"</span> + e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里模拟到达内存限定值，删除最不常用的那个元素</span></span><br><span class="line">Log.i(TAG, <span class="string">"delete: "</span> + linkedHashMap.keySet().iterator().next());</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;-&gt;1</span><br><span class="line">2 &lt;-&gt;2</span><br><span class="line">3 &lt;-&gt;3</span><br><span class="line">4 &lt;-&gt;4</span><br><span class="line">5 &lt;-&gt;5</span><br><span class="line">-------------</span><br><span class="line">1 &lt;-&gt;1</span><br><span class="line">2 &lt;-&gt;2</span><br><span class="line">5 &lt;-&gt;5</span><br><span class="line">4 &lt;-&gt;4</span><br><span class="line">3 &lt;-&gt;3</span><br><span class="line">delete: 1  // 要删除的元素</span><br></pre></td></tr></table></figure><p>根据结果可见，这确实跟我们跟我们前面所理解的一样，只不过上面是模拟操作，我们接下来看看 <code>LruCache</code> 对这部分的实现。首先定位到 <code>put</code> 方法，可见每次添加新元素时都会统计数量和空间大小、进行新旧元素的替换，然后检查是否超出空间限定值，如果超出，移除尾部最不常用的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许 key、value 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 统计添加到容器的元素数量</span></span><br><span class="line">        putCount++;</span><br><span class="line">        <span class="comment">// 统计容器中元素所占用的空间大小</span></span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="comment">// 如果 key 位置上已经存在元素，那么用新元素替换旧元素，并重新统计空间大小</span></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 key 上的旧元素删除掉</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超出容量时删除尾部最不常用的元素</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>trimToSize</code> 源码如下，跟集合自身的 <code>trimToSize</code> 功能不一样之处在于，集合自身的 <code>trimToSize</code> 用于去除多余的没有存放元素的空间，而这里是移除尾部最不常用的元素，些许类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 统计错误的情况</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                        + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 还有足够空间容量的情况</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 超出限定容量的情况</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 定位到尾部最不常用的元素，标记为删除</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                toEvict = entry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如如果容器没有元素，直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (toEvict == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            <span class="comment">// 否则，删除元素、重新统计空间容量</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知元素已经从容器中删除，可以做写清理工作</span></span><br><span class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、关于-LinkedHashMap"><a href="#三、关于-LinkedHashMap" class="headerlink" title="三、关于 LinkedHashMap"></a>三、关于 LinkedHashMap</h3><blockquote><p><strong>注意：</strong> 本文中 <code>LinkedHashMap</code>、<code>HashMap</code> 版本基于 <code>JDK8</code>；在<code>Android</code>中则基于<code>Android N</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code> 继承自 <code>HashMap</code>，因此我们先来回顾一下 <code>HashMap</code> 和祖先 <code>Hashtable</code> 的特性：</p><p><strong>内部构造：</strong></p><ul><li>当发生冲突（<code>key</code>的哈希值相同，但是他们并不<code>equals</code>）的量数据量较少（ <code>&lt; 8</code> ）时，<code>HashMap</code>和<code>Hashtable</code>都采用 <strong>数组 + 单向链表</strong> 这种结构作为解决方案；</li><li>当发生冲突的数据量较大（<code>&gt; 8</code>）时，不同于<code>Hashtable</code>，<code>HashMap</code>采用了<strong>数组 + 红黑树</strong>的解决方案；</li><li><code>HashMap</code>是一种非线程安全的数据结构，而<code>Hashtable</code>是</li></ul><p>上面描述了 <code>HashMap</code> 和 <code>Hashtable</code> 的主要区别，这种差异导致 <code>HashMap</code> 在操作性能和使用场景上都比 <code>Hashtable</code> 更胜一筹，并且你完全可以放弃使用 <code>Hashtable</code> ，而在并发场景下使用 <code>ConcurrentHashMap</code>；</p><p>回到 <code>HashMap</code>， 为什么 采用 <strong>数组 + 单向链表</strong> 和 <strong>数组 + 红黑树</strong> 两种切换方案呢？原因很简单，因为数据量很小时，使用单向链表的操作效率已经够高了，并且单向链表内部构造简单，能减少额外的空间分配；相应的，数据量大时采用红黑树，因为红黑树能够保证各操作的做坏时间复杂度为 <code>log(n)</code>，因此适用于数据量大且操作频繁的场景；</p><p><code>OK</code>， 有了上面的回顾内容，我们可以对 <code>LinkedHashMap</code> 有个初步的了解，接下来我们主要看看 <code>LinkedHashMap</code>中新增的排序规则。</p><p>首先来看看它的构造器，初始容量（<code>initialCapacity</code>）、加载因子（<code>loadFactor</code>）就不解释了，看到 参数 <code>accessOrder</code>，它用于控制是否开启 <strong>就近使用原则</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们假设开启了<strong>就近使用原则</strong>，获取元素时是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)  </span><br><span class="line">        afterNodeAccess(e);  </span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的节点是双向链表的节点,继承自 <code>HashMap.Node</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">    LinkedHashMapEntry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的 <code>afterNodeAccess</code>，源码如下，在这里会将节点移动到尾部，而这里的尾部代表最常使用的节点，也是最近节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; </span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">// 节点不在尾部</span></span><br><span class="line">            LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, <span class="comment">// 当前节点 </span></span><br><span class="line">            b = p.before,  <span class="comment">// 前一个节点</span></span><br><span class="line">            a = p.after;  <span class="comment">// 后一个节点</span></span><br><span class="line">            p.after = <span class="keyword">null</span>;  <span class="comment">// 剪断 当自己与后一个节点的连接 </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 将自己从链表中分离出来</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)  <span class="comment">// 前面没节点了，说明它自己是头部，那么直接让位给下一个节点</span></span><br><span class="line">                head = a;  </span><br><span class="line">            <span class="keyword">else</span>           <span class="comment">// 前面还有节点，那么将前一个节点连接到下一个节点，让位</span></span><br><span class="line">                b.after = a; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)  <span class="comment">// 因为是双向链表，所以这里 a 节点存在的时候需要重置一下前一个连接，</span></span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;  <span class="comment">// 不存在则直接把 befor 当成尾部</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">// 说明当前链表无节点， 那么直接把当前节点作为头部</span></span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;           <span class="comment">// 已经存在节点的话，那么将当前节点连接到尾部 </span></span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p; <span class="comment">// 尾部重新赋值一下</span></span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相对于 <code>HashMap</code> 而言， <code>LinkedHashMap</code> 使用双向链表而不是单向链表，并且有排序规则，能够对元素进行排序。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>嗯~，写到最后发现没啥话可说的了…嘿嘿</p><p>文中主要分析总结了一下 <code>LruCache</code> 的最近使用原则，接着回顾了一下 <code>LinkedHashMap</code> 相关的一些知识，如 <code>HashMap</code> 和 <code>Hashtable</code>，并具体分析了一下它在<code>get</code>元素时进行的操作规则;</p><p>总的来说，<code>LruCache</code>相当于<code>LinkedHashMap</code>的一层代理，自身控制内存大小，而将存储操作委托给了<code>LinkedHashMap</code>；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 源码分析</title>
      <link href="/2019/06/02/OkHttp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/OkHttp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>在我们日常开发中，<code>OkHttp</code>可谓是最常用的开源库之一，目前就连<code>Android API</code>中的网络请求接口都是用的<code>OkHttp</code>，好吧，真的很强。</p><p>在上学期间我也曾阅读和分析过<code>OkHttp</code>的源码，并记录在笔记中，不过现在再去翻看的时候发现当时很多地方并没有正确理解，因此也趁着这个过年假期重新阅读和整理一遍，感兴趣的童鞋可以观摩一下。</p><p>本文纯属基于个人理解，因此受限于知识水平，有些地方可能依然没有理解到位，还请发现问题的童鞋理性指出。</p><a id="more"></a><blockquote><p><strong>温馨提示： 本文很长，源码基于 <code>OKHttp-3.11.0</code></strong></p></blockquote><h3 id="二、从一个简单请求入手分析整体运作流程"><a href="#二、从一个简单请求入手分析整体运作流程" class="headerlink" title="二、从一个简单请求入手分析整体运作流程"></a>二、从一个简单请求入手分析整体运作流程</h3><h4 id="1-先来点关于-OkHttpClient-的官方释义"><a href="#1-先来点关于-OkHttpClient-的官方释义" class="headerlink" title="1. 先来点关于 OkHttpClient 的官方释义"></a>1. 先来点关于 OkHttpClient 的官方释义</h4><p><code>OkHttpClient</code>作为<code>Call</code>的工厂类，用于发送<code>HTTP</code>请求并读取相应数据。</p><p><strong><code>OkHttpClient</code>应当被共享</strong>.</p><p>使用<code>OkHttpClient</code>的最佳使用方式是创建一个<code>OkHttpClient</code>单例，然后复用这个单例进行所有的<code>HTTP</code>请求。为啥呢？因为每个<code>OkHttpClient</code>自身都会持有一个连接池和线程池，所以符用连接和线程可以减少延迟、节约内存。相反地，如果给每个请求都创建一个<code>OkHttpClient</code>的话，那就是浪费闲置线程池的资源。</p><p>可以如下使用<code>new OkHttpClient()</code>创建一个默认配置的共享<code>OkHttpClient</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final OkHttpClient client = new OkHttpClient();</span><br></pre></td></tr></table></figure><p>或使用 <code>new OkHttpClient.Builder()</code>来创建一个自定义配置的共享实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(new HttpLoggingInterceptor())</span><br><span class="line">    .cache(new Cache(cacheDir, cacheSize))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p><strong>可以通过<code>newBuilder()</code>来自定义<code>OkHttpClient</code></strong>，这样创建出来的<code>OkHttpClient</code>具有与原对象相同的连接池、线程池和配置。使用这个方法可以派生一个具有自己特殊配置的<code>OkHttpClient</code>以符合我们的特殊要求。</p><p>如下示例演示的就是如何派生一个读超时为500毫秒的<code>OkHttpClient</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient eagerClient = client.newBuilder()</span><br><span class="line">    .readTimeout(500, TimeUnit.MILLISECONDS)</span><br><span class="line">    .build();</span><br><span class="line">Response response = eagerClient.newCall(request).execute();</span><br></pre></td></tr></table></figure><p><strong>关闭（<code>Shutdown</code>）不是必须的</strong>。</p><p>线程和连接会一直被持有，直到当它们保持闲置时自动被释放。但是如果你编写的应用需要主动释放无用资源，那么你也可以主动去关闭。通过<code>shutdown()</code>方法关闭分发器<code>dispatcher</code>的执行服务，这将导致之后<code>OkHttpClient</code>收到的请求全部被拒绝掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.dispatcher().executorService().shutdown();</span><br></pre></td></tr></table></figure><p>清空连接池可以用<code>evictAll()</code>,不过连接池的守护线程可能不会马上退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.connectionPool().evictAll();</span><br></pre></td></tr></table></figure><p>如果相关比缓存，可以调用<code>close()</code>，注意如果缓存已经关闭了再创建<code>call</code>的话就会出现错误，并且会导致<code>call</code>崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.cache().close();</span><br></pre></td></tr></table></figure><p><code>OkHttp</code>同样会为所有<code>HTTP/2</code>连接建立守护线程，并且再它们保持闲置状态时自动关闭掉它们。</p><h4 id="2-常规使用"><a href="#2-常规使用" class="headerlink" title="2. 常规使用"></a>2. 常规使用</h4><p>上面的官方释义描述了<code>OkHttpClient</code>的最佳实践原则和清理操作，接下来我们根据一个简单的<code>GET</code>请求操作来引出我们要分析的问题：</p><p>如下创建一个<code>OkHttpClient</code>实例，添加了<code>Intercepter</code>，并在工程目录下建了个名为<code>cache</code>的<code>Cache</code>缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Interceptor logInterceptor = chain -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    System.out.println(request.url());</span><br><span class="line">    System.out.println(request.method());</span><br><span class="line">    System.out.println(request.tag());</span><br><span class="line">    System.out.println(request.headers());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .cache(<span class="keyword">new</span> Cache(<span class="keyword">new</span> File(<span class="string">"cache/"</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">        .addInterceptor(logInterceptor)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>然后一个普通的<code>GET</code>请求是这样的，这里以获取 <a href="http://wanandroid.com" target="_blank" rel="noopener">玩Android</a> 首页列表为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHomeList</span><span class="params">(<span class="keyword">int</span> page)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 建立HTTP请求</span></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(String.format(<span class="string">"http://wanandroid.com/article/list/%d/json"</span>, page))</span><br><span class="line">            .get()</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2. 基于 Request创建 Call</span></span><br><span class="line">    okhttp3.Call call = okHttpClient.newCall(request);</span><br><span class="line">    <span class="comment">// 3. 执行Call</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(response.message());</span><br><span class="line">            System.out.println(response.code());</span><br><span class="line">            System.out.println(response.headers());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful())&#123;</span><br><span class="line">                ResponseBody body = response.body();</span><br><span class="line">                <span class="keyword">if</span> (body == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(body.string());</span><br><span class="line">                <span class="comment">// 每个ResponseBody只能使用一次，使用后需要手动关闭</span></span><br><span class="line">                body.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-执行流程分析"><a href="#3-执行流程分析" class="headerlink" title="3. 执行流程分析"></a>3. 执行流程分析</h4><p>注意到上面的<code>okHttpClient.newCall(request)</code>，对应的源码如下，可知它创建的实际上是<code>Call</code>的实现类<code>RealCall</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);  </span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Call</code>提供请求任务的执行和取消和相关状态操作方法。类似于<code>FutureTask</code>，是任务执行单元，其核心的执行方法代码如下，包含同步执行(<code>execute()</code>)和异步执行(<code>enqueue()</code>)两种方式。<strong>对于同步方法而言，<code>RealCall</code>仅仅通过<code>executed()</code>方法将自身记录在<code>Dispatcher</code>（分发器）的同步请求队列中，这是为了在分发器中统计请求数量，在请求结束之后则通过<code>finished()</code>方法将自身从分发器中的同步请求队列中移除，而真正进行数据请求的是在拦截器<code>Intercepter</code></strong>，如下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 仅仅将这个 Call记录在分发器 ( Dispatcher )的同步执行队列中</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 2. 通过拦截器链获取响应数据，这里才会真正的执行请求</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 3.  拿到响应数据后从分发器的同步执行队列中移除当前请求</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进至<code>getResponseWithInterceptorChain()</code>，可以注意到，除了我们在创建<code>OkHttpClient</code>时添加的拦截器外，每个<code>HTTP</code>请求都会默认添加几个固有的拦截器，如<br><code>RetryAndFollowUpInterceptor</code>、<code>BridgeInterceptor</code>、<code>CacheInterceptor</code>、<code>ConnectInterceptor</code>、<code>CallServerInterceptor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于它们的源码实现会在后面的<strong>核心类解读</strong>中详细分析，这里先了解一个它们各自的作用：</p><ul><li><strong>RetryAndFollowUpInterceptor</strong>：用于失败时恢复以及在必要时进行重定向。</li><li><strong>BridgeInterceptor</strong>：应用代码与网络代码的桥梁。首先根据用户请求建立网络请求，然后执行这个网络请求，最后根据网络请求的响应数据建立一个用户响应数据。</li><li><strong>CacheInterceptor</strong>：用于从本地缓存中读取数据，以及将服务器数据写入到缓存。</li><li><strong>ConnectInterceptor</strong>：用于打开一个到目标服务器的连接，并切换至下一个拦截器。</li><li><strong>CallServerInterceptor</strong>：这是拦截器链的最后一环，至此将真正的进行服务器请求。</li></ul><p><strong>请求时整个拦截器的调用链的执行次序如下</strong>：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f0bc111a3f8d06f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器执行链"></p><p>对于请求时拦截器的调用链你可能会有所疑惑，为什么它是按这个次序执行的呢？咱看看<code>RealInterceptorChain#proceed(...)</code>方法的主要源码，发现，虽然这里看起来只进行了一次调用，但是如果你结合这些拦截器一起分析的话，你就会发现，其实这里对拦截器集合进行了递归取值，因为每次执行<code>proceed()</code>方法时集合索引<code>index</code>会 <code>+1</code>， 并将<code>index</code>传入新建的<code>RealInterceptorChain</code>，而拦截器集合唯一，因此相当于每次<code>proceed</code>都是依次取得拦截器链中的下一个拦截器并使用这个新建的<code>RealInterceptorChain</code>，执行<code>RealInterceptorChain#proceed</code>方法，直到集合递归读取完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 每次执行 proceed() 方法时 index+1， 然后传入新建的 RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">     <span class="comment">// 但是 拦截器集合是相同的，因此相当于每次都是依次取得拦截器链中的下一个拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归？</strong> 是的，如果你观察的够仔细的话，你会发现，其实<code>BridgeInterceptor</code>、<code>RetryAndFollowUpInterceptor</code>、<code>CacheInterceptor</code>、<code>ConnectInterceptor</code>都会执行<code>RealInterceptorChain#proceed</code>方法，相当于这个方法在不断地调用自己，符合递归的执行特性，因此<code>Response</code>响应数据的返回次序刚好是与请求时相反的。<code>BridgeInterceptor#intercept</code>相应抽取的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因而拦截器链的响应数据返回次序如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-e986fd97b4d130c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器链的响应次序"></p><p>我靠，是不是觉得设计的非常巧妙，这也是我热衷于源码的重要原因之一，因为不看看别人的代码你就永远不知道别人有多骚。。</p><p>根据上面的分析，我们已经知道了原来<strong>正真执行请求、处理响应数据是在拦截器，并且对于同步请求，分发器<code>Dispatcher</code>仅仅是记录下了同步请求的<code>Call</code>，用作请求数量统计用的，并没有参与到实际请求和执行中来。</strong></p><p>OK，来看看异步请求<code>RealCall#enqueue()</code>和<code>Dispatcher#enqueue()</code>，毫无疑问，异步请求肯定是运行在线程池中了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Dispatcher#enqueue()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的<code>AsyncCall</code>，核心源码如下，注意到<code>getResponseWithInterceptorChain()</code>，是不是非常地熟悉了，在上面的同步请求那里已经详细解释过了，就不再累赘了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>OkHttp</code>的主体运作流程是不是已经清晰了，不过有没有感觉还少点什么，我们只是分析了运作流程，具体到怎么连接的问题还没有分析。</p><p>好吧，既然是建立连接，那么极速定位到<code>ConnectInterceptor</code>，没毛病吧, 核心源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的<code>streamAllocation.newStream(..)</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">( OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      <span class="comment">// 1. 查找可用连接</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      <span class="comment">// 2. 建立 HTTP 或 HTTP2 连接</span></span><br><span class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        codec = resultCodec;</span><br><span class="line">        <span class="keyword">return</span> resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续定位到 <code>findHealthyConnection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 完全阻塞式查找，找不到不罢休</span></span><br><span class="line">      <span class="comment">// 1. 查找已有连接</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 如果这是一条全新的连接，那么可以跳过大量的健康检查，直接返回</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. 做一个速度超慢的检查，以确保池中的连接仍然可用，</span></span><br><span class="line">      <span class="comment">//    如果不可用了就将其从池中剔除，然后继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        noNewStreams();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到<code>StreamAllocation#findConnection</code>，这里<strong>查找连接的规则是：先查看当前是否存在可用连接，如果不存在，再从连接池中查找，如果还没有，那就新建一个，用来承载新的数据流。</strong> 需要注意的一个细节就是，从连接池查找连接时会查询两次，第一次只是根据当前目标服务器地址去查，如果没有查到，则第二次会重新选择路由表，然后用该地址去匹配。最终如果存在已经创建好的连接，则直接返回使用，如果不存在，则新建一个连接，进行<code>TCP</code>和<code>TLS</code>握手，完事之后将这个连接的路由信息记录在路由表中，并把这个连接保存到连接池。<strong>还需要注意的一点是：如果有个连接与当前建立的连接的地址相同，那么将释放掉当前建立好的连接，而使用后面创建的连接（保证连接是最新的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      <span class="comment">// 1. 检查当前有没有可用连接，如果有，那么直接用当前连接</span></span><br><span class="line">      releasedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">      toClose = releaseIfNoNewStreams();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123; <span class="comment">// 可用</span></span><br><span class="line">        result = <span class="keyword">this</span>.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 2. 不存在已有连接或者已有连接不可用，则尝试从连接池中获得可用连接</span></span><br><span class="line">        Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedRoute = route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123; <span class="comment">// 已有连接中找到了连接,完成任务</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 选择一条路由，这是个阻塞式操作</span></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">          <span class="comment">// 路由已经选好了，此时再根据路由中的 IP集合去匹配连接池中的连接，</span></span><br><span class="line">          <span class="comment">// 这个可能因为连接合并的缘故而匹配到</span></span><br><span class="line">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">          Route route = routes.get(i);</span><br><span class="line">          Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">          <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">            result = connection;</span><br><span class="line">            <span class="keyword">this</span>.route = route;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 最后实在没找到已有的连接，那么就只能重新建立连接了</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据路由匹配到了连接池中的连接</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 TCP + TLS 握手. 这是阻塞式操作</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    routeDatabase().connected(result.route()); <span class="comment">// 路由表中记录下这个连接的路由信息</span></span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 将这个连接记录到连接池</span></span><br><span class="line">      Internal.instance.put(connectionPool, result);</span><br><span class="line">      <span class="comment">// 如果多个连接指向当前创建的连接的相同地址，那么释放掉当前连接，使用后面创建的连接</span></span><br><span class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上分析可得出以下主体执行流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-d15b7b6118737e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OkHttp主体执行流程.png"></p><p>当然这是同步请求的流程，而对于异步请求而言，也仅仅是把拦截器链放到了线程池执行器中执行而已。</p><h3 id="三、核心类解读"><a href="#三、核心类解读" class="headerlink" title="三、核心类解读"></a>三、核心类解读</h3><p>至此，我们已经清楚了<code>OkHttp</code>的主干，当然，我们仅仅是把流程给走通了，在本节中，我们将根据源码具体分析<code>OkHttp</code>中各核心类的作用及其实现，内容很长，请做好心理准备。</p><h4 id="1-拦截器（Intercepter）"><a href="#1-拦截器（Intercepter）" class="headerlink" title="1. 拦截器（Intercepter）"></a>1. 拦截器（<code>Intercepter</code>）</h4><p><strong>1). RetryAndFollowUpInterceptor</strong></p><p>作用：用于失败时恢复以及在必要时进行重定向。</p><p>作为核心方法，<code>RetryAndFollowUpInterceptor#intercept</code>体现了<code>RetryAndFollowUpInterceptor</code>的工作流程，源码如下，我们来分析分析它是怎么恢复和重定向的，具体实现流程还请看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = chain.request();</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Call call = realChain.call();</span><br><span class="line">  EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅仅创建流的承载对象，此时并没有建立流</span></span><br><span class="line">  StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">      createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">  <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> followUpCount = <span class="number">0</span>; <span class="comment">// 用于记录重定向和需要授权请求的数量</span></span><br><span class="line">  Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果此时请求被取消了，那么关闭连接，释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123; </span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 推进执行拦截器链，请求并返回响应数据</span></span><br><span class="line">      response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      <span class="comment">// 3. 如果连接失败了，尝试使用失败的地址恢复一下，此时请求可能还没有发送</span></span><br><span class="line">      <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">      &#125;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// 4. 尝试重新与交流失败的服务器重新交流，这个时候请求可能已经发送了</span></span><br><span class="line">      <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">      <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">      releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 5. 如果是位置异常，那么释放掉所有资源</span></span><br><span class="line">      <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">        streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 如果记录的上一个请求大的响应数据存在，那么将其响应体置空</span></span><br><span class="line">    <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(<span class="keyword">null</span>)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request followUp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 7. 处理请求的认证头部、重定向或请求超时问题，如果这些操作都不必要</span></span><br><span class="line">      <span class="comment">//    或者应用不了，那么返回 null</span></span><br><span class="line">      followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要处理认证、重定向和超时问题，那么结束处理，返回响应数据</span></span><br><span class="line">    <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，关闭当前响应，进行后续重定向等问题的处理</span></span><br><span class="line">    closeQuietly(response.body());</span><br><span class="line">    <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">          createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">      <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">          + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = followUp;</span><br><span class="line">    priorResponse = response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). BridgeInterceptor</strong></p><p>作用：应用代码与网络代码的桥梁。首先根据用户请求建立网络请求，然后执行这个网络请求，最后根据网络请求的响应数据建立一个用户响应数据。</p><p><code>BridgeInterceptor#intercept</code>源码如下，主要做了以下事情：</p><ul><li><strong>用于请求：</strong> 这个是在推进请求拦截器链时进行的，也就是说此时尚未真正地进行网络请求。此时会补充缺失的请求头参数，如 <code>Content-Type</code>、<code>Transfer-Encoding</code>、<code>Host</code>、<code>Connection</code>、<code>Accept-Encoding</code>、<code>User-Agent</code>、<code>Cookie</code>。如果在请求时添加了<code>gzip</code>请求头参数，即开启了<code>gzip</code>压缩，那么在取得响应数据时需要对数据进行解压。</li><li><strong>用于响应：</strong> 这个实在取得网络响应数据后回退拦截器链时进行的，即已经取得了网络响应数据。此时会对相应头部进行处理，如果请求时开启了<code>gzip</code>压缩，那么此时会对响应数据进行解压。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里处于请求之前</span></span><br><span class="line">  <span class="comment">// 1. 此时主要为请求添加缺失的请求头参数</span></span><br><span class="line">  RequestBody body = userRequest.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 如果启用了GZIP压缩，那么需要负责解压响应数据</span></span><br><span class="line">  <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">    requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 推进执行拦截器链，进行请求、返回数据</span></span><br><span class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得网络响应数据后</span></span><br><span class="line">  <span class="comment">// 3. 处理响应头，如果请求时开启了GZIP压缩，那么这里需要将响应数据解压</span></span><br><span class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip</span><br><span class="line">      &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">      &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">    GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">    Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">        .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">        .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">        .build();</span><br><span class="line">    responseBuilder.headers(strippedHeaders);</span><br><span class="line">    String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">    <span class="comment">// 建立用户响应数据</span></span><br><span class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，<code>BridgeInterceptor</code>主要用于请求前对用户请求进行完善，补充缺失参数，然后推进请求拦截器链，并等待响应数据返回，取得响应数据后则是将其转换成用户响应数据，此时如果数据进行过<code>gzip</code>压缩，那么会在这里进行解压，然后重新封装成用户数据。</p><p><strong>3). CacheInterceptor</strong></p><p>作用：用于从本地缓存中读取数据，以及将服务器数据写入到缓存。</p><p><code>CacheInterceptor#intercept</code>源码如下，拦截器链执行到这一步主要做了如下事情：</p><ul><li><p><strong>请求：</strong> </p><p>如果开启了缓存，且请求策略是禁用网络仅读缓存的话，那么首先会根据当前请求去查找缓存，如果匹配到了缓存，则将缓存封装成响应数据返回，如果没有匹配到，那么返回一个<code>504</code>的响应，这将导致请求拦截器链执行终止，进而返回执行响应拦截器链。</p><p>如果请求策略是网络加缓存，当那么然网络请求优先，所以就推进请求拦截器链执行请求，</p></li><li><p><strong>网络响应：</strong> </p><p>在得到网络响应数据后，如果开启了缓存策略其匹配到了旧缓存，那么根据最新网络请求响应数据更新缓存，然后返回响应数据；如果没有匹配到缓存但是开启了缓存，那么将响应数据写入缓存后返回；而如果开启了缓存，但是并不使用缓存策略，那么根据响应数据移除缓存中对应的数据缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//  读取候选的旧缓存</span></span><br><span class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 解析请求和缓存策略</span></span><br><span class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  Request networkRequest = strategy.networkRequest; <span class="comment">// 如果仅读缓存，那么网络请求会为 null</span></span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// 如果禁止使用网络而仅读取缓存的话，那么没匹配到缓存时返回 504</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果禁止使用网络而仅读取缓存的话，那么匹配到缓存时将其返回</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 推进执行请求拦截器链</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 请求异常则关闭候选缓存实体</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据最新网络请求响应数据更新缓存，然后返回响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 无匹配缓存的情况</span></span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// 使用缓存策略且无匹配缓存，则将响应数据写入缓存</span></span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// 不使用缓存策略，则删除已有缓存</span></span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>缓存时判断逻辑比较多，不过这里重点在于理解缓存策略，一般会有：<strong>仅网络</strong>、<strong>仅缓存</strong>、<strong>网络加缓存</strong> 三种请求策略。</p><p><strong>4). ConnectInterceptor</strong></p><p>作用：用于打开一个到目标服务器的连接，并切换至下一个拦截器</p><p>因为在上一节末尾分析<code>OkHttp</code>如何建立连接的问题上已经分析过了，所以不做过多描述。</p><p>这里回忆一下连接规则：建立连接时，首先会查看当前是否有可用连接，如果没有，那么会去连接池中查找，如果找到了，当然就使用这个连接，如果没有，那么就新建一个连接，进行<code>TCP</code>和<code>TLS</code>握手以建立联系，接着把连接放入连接池以备后续复用，最后推进请求拦截器链执行，将打开的连接交给下一个拦截器去处理。</p><p><strong>5). CallServerInterceptor</strong></p><p>作用：这是拦截器链的最后一环，至此将真正的进行服务器请求</p><p><code>CallServerInterceptor#intercept</code>源码如下，作为拦截器链的最后一环，当然要真正地做点实事了，大致操作步骤是：</p><p>发送请求头部 –&gt;  读取一下<code>GET</code>、<code>HEAD</code>之外的请求（如<code>POST</code>）的响应数据 –&gt; 结束请求的发送动作 –&gt; 读取响应头部 –&gt; 读取响应数据 –&gt; 封装后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 发送请求头部</span></span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 2. 检查是否是 GET 或 HEAD 以外的请求方式、读取响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果请求头部中包含"Expect: 100-continue"，那么在转换请求体前等待"HTTP/1.1 100 Continue"</span></span><br><span class="line">    <span class="comment">// 响应。如果没有读取到"HTTP/1.1 100 Continue"的响应，那么就不转换请求体(request body)了，</span></span><br><span class="line">    <span class="comment">// 而直接将我们得到的响应返回（如 状态为 4XX 的响应 ）；</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      <span class="comment">// 读取、转换响应头部</span></span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果存在"Expect: 100-continue"，则写入请求体</span></span><br><span class="line">      <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">          <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">      <span class="comment">// 如果不存在"Expect: 100-continue"，那么禁止 HTTP/1 连接复用。</span></span><br><span class="line">      <span class="comment">// 不过我们仍然必须转换请求体以使连接达到一个固定的状态。</span></span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 结束请求的发送动作</span></span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 读取响应头部</span></span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 构建响应数据</span></span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果服务器返回 100-continue 响应即使我们并没有这么请求，则重新读取一遍响应数据；</span></span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    response = responseBuilder</span><br><span class="line">            .request(request) </span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6. 填充响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// 连接正在更新，不过我们需要确保拦截器收到的 non-null 的响应体</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里将 http 输入流包装到响应体</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况...</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，作为拦截器最后一环的<code>CallServerInterceptor</code>终于把请求给终结了，完成了与服务器的沟通交流，把需要的数据拿了回来。请求的时候每个拦截器都会插上一脚，响应的时候也一样，把数据转换的工作分给了各个拦截器处理。</p><h4 id="2-分发器（Dispatcher）"><a href="#2-分发器（Dispatcher）" class="headerlink" title="2. 分发器（Dispatcher）"></a>2. 分发器（<code>Dispatcher</code>）</h4><p>为什么叫分发器呢？如果叫做执行器(<code>Executor</code>)可能会更好理解一些，因为它的工作就是执行异步请求，虽然会统计请求的数量….嗯~~好吧，换个角度，如果理解为它用于把异步任务分发给线程池执行，起到任务分发的作用，那就理解为啥叫分发器了。</p><p>OK，先来观察一下<code>Dispatcher</code>的构成，部分源码如下，可以先看看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;  <span class="comment">// 同时执行的最大异步请求数量，数量超过该值时，新增的请求会放入异步请求队列中</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;  <span class="comment">// 每个主机最多同时存在的请求数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 线程池执行器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line">  <span class="comment">// 尚未执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">// 正在执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">// 同步执行的任务队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化线程池执行器</span></span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单描述一下：<code>Dispatcher</code>包含三个任务队列，分别用于记录尚未执行的异步请求、正在执行的异步请求、正在执行的同步请求。包含一个线程池，用于执行异步请求，这个线程池执行器的核心线程数量为 <code>0</code>， 最大线程数量不限（整型的最大值<code>2^31-1</code>，相当于不限），闲置线程的最大等待超时时间为<code>60</code>秒,线程池的任务队列使用非公平机制的<code>SynchronousQueue</code>。这就是<code>Dispatcher</code>的主要配置。</p><p>我们来看看它是如何限制每个主机的请求数量的，直接看注释好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正在执行的异步请求数量小于限定值，且同一主机的正在执行的异步请求数量小于限定值时</span></span><br><span class="line">    <span class="comment">// 添加到正在执行的异步请求队列中，并执行。</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就添加到等待队列中</span></span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>runningCallsForHost</code>用于计算当前正在执行的连接到相同主机上异步请求的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the number of running calls that share a host with &#123;<span class="doctag">@code</span> call&#125;. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">runningCallsForHost</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (AsyncCall c : runningAsyncCalls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.get().forWebSocket) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (c.host().equals(call.host())) result++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-连接池（ConnetionPool）"><a href="#3-连接池（ConnetionPool）" class="headerlink" title="3. 连接池（ConnetionPool）"></a>3. 连接池（<code>ConnetionPool</code>）</h4><p>作用：用于管理<code>HTTP</code>和<code>HTTP/2</code>连接的复用以减少网络延迟，因为使用相同地址的请求可能共享一个连接。所以<code>ConnetionPool</code>实现了维护已打开连接已被后续使用的机制。</p><p>线程池啥的就不多说了，这里主要分析一下<code>ConnetionPool</code>如何维护已打开的连接。从<code>ConnetionPool#put</code>着手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123; <span class="comment">// 如果当前不在执行清理任务，那么现在执行</span></span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    executor.execute(cleanupRunnable); <span class="comment">// 线程池的作用就是执行清理任务</span></span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection); <span class="comment">// 同时添加到连接队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cleanupRunnable</code>源码如下，根据<code>ConnetionPool#put</code>可知每当我们往连接池中添加一个连接时，如果当前不在执行清理任务(<code>cleanupRunnable</code>)，那么立马会执行<code>cleanupRunnable</code>，而<code>cleanupRunnable</code>中会循环执行<code>cleanup</code>，直到所有连接都因闲置超时而被清理掉，具体还请先看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime()); <span class="comment">// 执行清理</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// cleanup中的情况 4)</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;  <span class="comment">// cleanup中的情况 2) 和 3)  </span></span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos); <span class="comment">// 等待超时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 至此情况 1), 2), 3) 都会导致 `cleanup`被循环执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>cleanup</code>源码如下，它的作用是查找、清理超过了<code>keep-alive</code>时间限制或者闲置超时闲置的连接。具体还请看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 查找超时连接</span></span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="comment">// 1). 如果正在使用，那么跳过，继续查找</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++; <span class="comment">// 记录闲置连接的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2). 如果闲置时间超过了最大允许闲置时间，则记录下来在后面清除</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 查找完成了，将在这里对闲置连接进行处理</span></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// 1). 确定已经超时了，那么从连接池中清除，关闭动作会在同步块外面进行</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2). 存在闲置连接，但是尚未超时</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3). 如果所有连接都正在使用，那么最多保持个`keep-alive`超时时间就又会重新执行清理动作</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4). 压根没有连接，那不管了，标记为非清理状态，并返回-1</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭上面查找到的处于情况1)的闲置超时连接</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="comment">// 返回 0 ，表示马上会重新回来执行清理操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>综上，<code>ConnectionPool</code> 会设定<code>keepAliveDurationNs</code>、<code>longestIdleDurationNs</code>两个超时时间，而每次往连接池中添加一个新连接时，如果当前处于非清理装填，都会导致线程池执行器开个线程执行清理动作，而对于清理动作而言，会遍历连接池，查找闲置超时的连接，并记录闲置连接的数量，而遍历完成后，将根据情况 1)、2)、3)、4) 进行相应的处理，而如果是情况 4)， 则会当即结束清理循环，意味着连接池中已经没有连接了，此时线程会执行完成而退出，其他几种情况都不会中断循环，因此实际上这个线程池最多只会存在一个连接池维护线程。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>一般来说，当使用<code>OKHttp</code>通过<code>URL</code>请求时，它做了以下事情：</p><ul><li>使用<code>URL</code>并且配置<code>OKHttpClient</code>来创建地址(<code>Address</code>)，这个地址指定了我们连接<code>web</code>服务器的方式。</li><li>尝试从连接池(<code>ConnectionPool</code>)中取出与该地址相同的连接。</li><li>如果在连接池中没有对应该地址的连接，那么它会选择一条新路线（<code>route</code>）去尝试，这通常意味着将进行<code>DNS</code>请求以获取对应服务器的<code>IP</code>地址，然后如果需要的话还会选择<code>TLS</code>版本和代理服务器。</li><li>如果这是一条新路线，它会通过<code>Socket</code>连、<code>TLS</code>隧道（HTTP代理的HTTPS）或者<code>TLS</code>连接，然后根据需要进行<code>TCP</code>、<code>TLS</code>握手。</li><li>发送<code>HTTP</code>请求，然后读取响应数据。</li></ul><p>如果连接出现问题，<code>OKHttp</code>会选择另一条路线再次尝试，这使得<code>OKHttp</code>在服务器地址子集无法访问时能够恢复，而当从连接池中拿到的连接已经过期，或者<code>TLS</code>版本不支持的情况下，这种方式同样很有用。一旦接收到响应数据，该连接就会返回到连接池中以备后续请求使用，而连接池中的连接也会在一定时间的不活动状态后被清除掉。</p><p>对于整体框架而言，本文已经详细分析了<code>OkHttp</code>的整体工作流程，相关细节还请回到文中去，这里就不再累赘了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 第三方库源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用可观察数据对象 [翻译]</title>
      <link href="/2019/06/02/%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1-%5B%E7%BF%BB%E8%AF%91%5D/"/>
      <url>/2019/06/02/%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1-%5B%E7%BF%BB%E8%AF%91%5D/</url>
      
        <content type="html"><![CDATA[<p>官方英文文档：<a href="https://developer.android.google.cn/topic/libraries/data-binding/observability" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/data-binding/observability</a></p><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>观察能力是指一个对象可以通知别人它的数据已经发生改变的能力。<code>DataBinding</code>库允许你让你的对象、字段、集合具备观察能力。</p><p>普通对象可以用于<code>DataBinding</code>，但是它们不会自动通知<code>UI</code>它们发生改变了. <code>DataBinding</code>可以赋予对象在数据改变时通知其他对象的能力 。</p><a id="more"></a><h3 id="二、可观察字段（Observable-Fields）"><a href="#二、可观察字段（Observable-Fields）" class="headerlink" title="二、可观察字段（Observable Fields）"></a>二、可观察字段（<code>Observable Fields</code>）</h3><p>当对象只有少量有效字段时，就没有必要创建一个实现<code>Observable</code>接口的类了，对于这种情况，可以使用以下专用类来让字段具备观察能力。</p><ul><li><code>ObservableBoolean</code></li><li><code>ObservableByte</code></li><li><code>ObservableChar</code></li><li><code>ObservableShort</code></li><li><code>ObservableInt</code></li><li><code>ObservableLong</code></li><li><code>ObservableFloat</code></li><li><code>ObservableDouble</code></li><li><code>ObservableParcelable</code></li></ul><p>可观察对象只有单个字段，基本类型版本在访问时可以避免自动装箱和自动拆箱，而要使用这一机制，可以如下创建<code>public final</code>的<code>Java</code>属性，或者创建只读<code>read-only</code>的<code>Kotlin</code>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// java </span><br><span class="line">private static class User &#123;</span><br><span class="line">    public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;();</span><br><span class="line">    public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;();</span><br><span class="line">    public final ObservableInt age = new ObservableInt();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// kotlin</span><br><span class="line">class User &#123;</span><br><span class="line">    val firstName = ObservableField&lt;String&gt;()</span><br><span class="line">    val lastName = ObservableField&lt;String&gt;()</span><br><span class="line">    val age = ObservableInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>set</code>、<code>get</code>方法刚问字段值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// kotlin </span><br><span class="line">user.firstName = &quot;Google&quot;</span><br><span class="line">val age = user.age</span><br><span class="line"></span><br><span class="line">// java</span><br><span class="line">user.firstName.set(&quot;Google&quot;);</span><br><span class="line">int age = user.age.get();</span><br></pre></td></tr></table></figure><p> <strong>Note：</strong> 在<code>Android studio 3.1</code>及以上版本中可以通过使用<code>LiveData</code>来替换可观察字段，并且使用<code>LiveData</code>可以带来额外的好处，具体看 <a href="https://developer.android.google.cn/topic/libraries/data-binding/architecture.html#livedata" target="_blank" rel="noopener">这里</a>.</p><h3 id="三、可观察集合"><a href="#三、可观察集合" class="headerlink" title="三、可观察集合"></a>三、可观察集合</h3><p> 一些应用需要使用动态数据结构来来存储数据，可观察集合允许通过<code>key</code>来访问这些数据结构，如 <code>ObservableArrayMap</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // Kotlin</span><br><span class="line">ObservableArrayMap&lt;String, Any&gt;().apply &#123;</span><br><span class="line">    put(&quot;firstName&quot;, &quot;Google&quot;)</span><br><span class="line">    put(&quot;lastName&quot;, &quot;Inc.&quot;)</span><br><span class="line">    put(&quot;age&quot;, 17)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line">ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();</span><br><span class="line">user.put(&quot;firstName&quot;, &quot;Google&quot;);</span><br><span class="line">user.put(&quot;lastName&quot;, &quot;Inc.&quot;);</span><br><span class="line">user.put(&quot;age&quot;, 17);</span><br></pre></td></tr></table></figure><p>而在布局中的使用方法如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableMap&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableMap&lt;String, Object&gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text=&quot;@&#123;String.valueOf(1 + (Integer)user.age)&#125;&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><p><code>ObservableArrayList</code>在<code>key</code>为整型数据时非常有用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin</span><br><span class="line">ObservableArrayList&lt;Any&gt;().apply &#123;</span><br><span class="line">    add(&quot;Google&quot;)</span><br><span class="line">    add(&quot;Inc.&quot;)</span><br><span class="line">    add(17)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// java</span><br><span class="line">ObservableArrayList&lt;Object&gt; user = new ObservableArrayList&lt;&gt;();</span><br><span class="line">user.add(&quot;Google&quot;);</span><br><span class="line">user.add(&quot;Inc.&quot;);</span><br><span class="line">user.add(17);</span><br></pre></td></tr></table></figure><p>对用在布局中可以通过索引来访问这个列表的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableList&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.my.app.Fields&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableList&lt;Object&gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text=&apos;@&#123;user[Fields.LAST_NAME]&#125;&apos;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text=&apos;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&apos;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="四、可观察对象"><a href="#四、可观察对象" class="headerlink" title="四、可观察对象"></a>四、可观察对象</h3><p>实现了<code>Observable</code>接口的类允许注册的监听器接收到它的字段数据发生改变的通知。</p><p><code>Observable</code>接口包含注册和移除监听器的机制，但是我们需要决定什么是时候发送通知，为了方便开发，<code>Databinding</code>库提供了<code>BaseObservable</code>类来实现这个监听器注册机制。继承了<code>BaseObservable</code>的类负责在对象属性改变时发送通知，当给<code>get</code>方法加上<code>@Bindable</code>注解，且在<code>set</code>方法中调用<code>notifyPropertyChanged</code>方法时，这个流程就完成了，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Java</span><br><span class="line">private static class User extends BaseObservable &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getFirstName() &#123;</span><br><span class="line">        return this.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirstName(String firstName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Kotlin</span><br><span class="line">class User : BaseObservable() &#123;</span><br><span class="line"></span><br><span class="line">    @get:Bindable</span><br><span class="line">    var firstName: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.firstName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @get:Bindable</span><br><span class="line">    var lastName: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Data Binding</code>会在模块包生成一个叫做<code>BR</code>的类，它包含了用于数据绑定的资源<code>ID</code>，<code>@Bindable</code>注解则会在编译时在<code>BR</code>中生成一个<code>entry</code>。如果数据类仍不能改变，那么可以通过<code>PropertyChangeRegistry</code>对象注册和高效地通知监听器。</p><h3 id="关于-Bindable"><a href="#关于-Bindable" class="headerlink" title="关于 Bindable"></a>关于 Bindable</h3><p><strong><code>@Bindable</code>必须作为<code>get</code>方法的注解</strong>，如下示例，注意到<code>@Bindable({&quot;firstName&quot;, &quot;lastName&quot;}}</code>, 这里可以绑定多个字段，而在这些字段中，当有一个字段被更新后，与之相关联的字段（如这里的<code>name</code>，它依赖于<code>firstName</code>和<code>lastName</code>）都会被视作垃圾数据而被更新。但是这并不意味会<code>onPropertyChanged(Observable, int)</code>会接收到因为<code>BR.name</code>变成垃圾数据而触发的通知，<strong>当且仅当绑定表达式（<code>binding expressions</code>）中包含<code>name</code>字段的情况才会被视作垃圾数据并更新</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bindable</span><br><span class="line"> public void getFirstName() &#123; return this.firstName; &#125;</span><br><span class="line"></span><br><span class="line"> @Bindable</span><br><span class="line"> public void getLastName() &#123; return this.lastName; &#125;</span><br><span class="line"></span><br><span class="line"> @Bindable(&#123;&quot;firstName&quot;, &quot;lastName&quot;&#125;&#125;</span><br><span class="line"> public void getName() &#123; return this.firstName + &apos; &apos; + this.lastName; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DataBinding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据绑定适配器（Binding-Adapters）[翻译]</title>
      <link href="/2019/06/02/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88Binding-Adapters%EF%BC%89%5B-%E7%BF%BB%E8%AF%91%5D/"/>
      <url>/2019/06/02/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88Binding-Adapters%EF%BC%89%5B-%E7%BF%BB%E8%AF%91%5D/</url>
      
        <content type="html"><![CDATA[<p>官方英文原文：<a href="https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters</a></p><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p><code>Binding Adapter</code>负责调用合适的框架调用来设置值，例如通过<code>setText</code>设置属性值、通过<code>setOnclickListener</code>设置事件监听器等。</p><p><code>Databinging</code>类库允许通过调用特定的方法设置值、允许自定义绑定逻辑、允许指定适配器的返回类型。</p><h3 id="二、设置属性值"><a href="#二、设置属性值" class="headerlink" title="二、设置属性值"></a>二、设置属性值</h3><p>每当一个已经绑定的值发生改变时，生成的绑定类都必须通过<code>View</code>的数据绑定表达式来设置值。也可以通过<code>Databinding</code>类库自动决定需要的方法，或者显式声明所需方法、或者提供自定义逻辑的方法。</p><p><strong>1. 自动选择方法</strong></p><p> 假设存在一个属性<code>example</code>，那么类库会自动去查找可以接受对应参数的<code>setExample(arg)</code>方法，并不需要考虑属性的命名空间，搜索方法时只会用到属性的名称和类型。<br> <a id="more"></a><br> 比方说，给定<code>android:text=&quot;@{user.name}&quot;</code>表达式，类库就会查找可以接受<code>user.getName()</code>返回数据类型的<code>setText(arg)</code>方法，如果<code>user.getName()</code>返回的是<code>String</code>类型，那么就找一个能够接受<code>String</code>类型参数的<code>setText(arg)</code>方法</p><p> <strong>注意</strong>：如果返回<code>int</code>类型，但是又找不到参数为<code>int</code>类型的<code>setText(arg)</code>方法,那么就会报错了，因此需要注意参数是否匹配，如果不匹配，就需要进行数据转换。</p><p> 如果不存在与给定值相匹配的属性，<code>DataBinding</code>也能工作。可以通过使用数据绑定来创建与<code>set</code>方法相匹配的属性。比如说，<code>DrawerLayout</code>没有任何<code>Xml</code>属性，但是又大量的<code>set</code>属性的方法。 下面布局将使用<code>setScrimColor(int)</code>和<code>setDrawerListener(DrawerListener)</code>方法作为<code>app:scrimColor</code>和<code>app:drawerListener</code>属性的的<code>set</code>方法。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   app:scrimColor=&quot;@&#123;@color/scrim&#125;&quot;</span><br><span class="line">   app:drawerListener=&quot;@&#123;fragment.drawerListener&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2. 指定自定义的方法名</strong></p><p>有些属性存在与之不匹配的<code>set</code>方法，对于这种情况，一个属性可以通过使用<code>@BindMethods</code>注解来关联<code>set</code>方法。<code>@BindMethods</code>可以看成是一个类，包含多个<code>@BindMethod</code>注解，并且一个<code>@BindMethod</code>代表一个重命名的方法，<code>@BindMethods</code>可以存在于任何一个类中，如下示例，<code>android:tint</code>与<code>setImageTintList(ColorStateList)</code>方法相关联，而不是<code>setTint()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// kotlin</span><br><span class="line">@BindingMethods(value = [</span><br><span class="line">    BindingMethod(</span><br><span class="line">        type = android.widget.ImageView::class,</span><br><span class="line">        attribute = &quot;android:tint&quot;,</span><br><span class="line">        method = &quot;setImageTintList&quot;)])</span><br><span class="line"></span><br><span class="line">// java</span><br><span class="line">@BindingMethods(&#123;</span><br><span class="line">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span><br><span class="line">                      attribute = &quot;android:tint&quot;,</span><br><span class="line">                      method = &quot;setImageTintList&quot;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>大多数情况下，都不需要我们重命名<code>Android framework</code>类中已经存在的方法，因为这些方法已经实可以通过给定属性来进行匹配了。</p><p><strong>3. 提供自定义逻辑</strong></p><p>一些属性需要自定义绑定逻辑。比方说<code>android:paddingLeft</code>并没有与之对应的<code>set</code>方法，但是有个用于设置该属性的<code>setPadding(left, top, right, bottom)</code>方法，针对这一问题，使用<code>BindingAdapter</code>注解则能允许我们自定义这个属性调用<code>set</code>方法的方式。</p><p><code>Android framework</code>中类已经为属性建立了<code>BindingAdapter</code>注解。以下是如何为<code>andriod:paddingLeft</code>属性建立<code>BindingAdapter</code>的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// kotlin</span><br><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">fun setPaddingLeft(view: View, padding: Int) &#123;</span><br><span class="line">    view.setPadding(padding,</span><br><span class="line">                view.getPaddingTop(),</span><br><span class="line">                view.getPaddingRight(),</span><br><span class="line">                view.getPaddingBottom())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// java</span><br><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int padding) &#123;</span><br><span class="line">  view.setPadding(padding,</span><br><span class="line">                  view.getPaddingTop(),</span><br><span class="line">                  view.getPaddingRight(),</span><br><span class="line">                  view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数类型很重要的。</strong> 第一个参数决定与这个属性相绑定的<code>View</code>类型，第二个参数决定了通过绑定表达式传入的数据参数类型。</p><p><code>BingAdapter</code>对于其他自定义功能同样很有用，比方说，自定义图片加载器，用于从工作线程中加载图片等。</p><p><strong>当自定义的<code>BdingAdapter</code>在<code>Android framework</code>中已存在时，那么我们定制的方法会复写掉<code>Android framework</code>的方法。</strong></p><p><code>BingAdapter</code>可以接接收多个属性参数，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin</span><br><span class="line">@BindingAdapter(&quot;imageUrl&quot;, &quot;error&quot;)</span><br><span class="line">fun loadImage(view: ImageView, url: String, error: Drawable) &#123;</span><br><span class="line">    Picasso.get().load(url).error(error).into(view)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Java</span><br><span class="line">@BindingAdapter(&#123;&quot;imageUrl&quot;, &quot;error&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url, Drawable error) &#123;</span><br><span class="line">  Picasso.get().load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如下在布局中使用，其中<code>@drawable/venueError</code>是一个应用中的资源文件，通过<code>@{}</code>来建立正确的绑定表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView app:imageUrl=&quot;@&#123;venue.imageUrl&#125;&quot;</span><br><span class="line">            app:error=&quot;@&#123;@drawable/venueError&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong> <code>DataBinding</code>类库在进行匹配时会忽略自定义的命名空间。</p><p>当<code>imageUrl</code>和<code>error</code>都用于一个<code>ImageView</code>对象，且<code>imageUrl</code>是<code>String</code>类型、<code>error</code>是<code>Drawable</code>类型时，这个<code>BindingAdapter</code>才会被调用。而<strong>如果想要让这个适配器在不完整参数属性时也能被调用，那么可以设置<code>requireAll</code>标记为<code>false</code></strong>（说白了就是声明不需要全部参数都存在时也能被数据绑定使用，如果<code>true</code>则需要全部参数都存在），如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin</span><br><span class="line">@BindingAdapter(value = [&quot;imageUrl&quot;, &quot;placeholder&quot;], requireAll = false)</span><br><span class="line">fun setImageUrl(imageView: ImageView, url: String, placeHolder: Drawable) &#123;</span><br><span class="line">    if (url == null) &#123;</span><br><span class="line">        imageView.setImageDrawable(placeholder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MyImageLoader.loadInto(imageView, url, placeholder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line">@BindingAdapter(value=&#123;&quot;imageUrl&quot;, &quot;placeholder&quot;&#125;, requireAll=false)</span><br><span class="line">public static void setImageUrl(ImageView imageView, String url, Drawable placeHolder) &#123;</span><br><span class="line">  if (url == null) &#123;</span><br><span class="line">    imageView.setImageDrawable(placeholder);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    MyImageLoader.loadInto(imageView, url, placeholder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BindingAdapter</code>方法可以选择在它们的处理器中使用旧值。<strong>如果一个方法包含旧值和新值，那么所有旧值都必须定义在第一个属性（在新值属性之前）</strong>，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// kotlin</span><br><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">fun setPaddingLeft(view: View, oldPadding: Int, newPadding: Int) &#123;</span><br><span class="line">    if (oldPadding != newPadding) &#123;</span><br><span class="line">        view.setPadding(padding,</span><br><span class="line">                    view.getPaddingTop(),</span><br><span class="line">                    view.getPaddingRight(),</span><br><span class="line">                    view.getPaddingBottom())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123;</span><br><span class="line">  if (oldPadding != newPadding) &#123;</span><br><span class="line">      view.setPadding(newPadding,</span><br><span class="line">                      view.getPaddingTop(),</span><br><span class="line">                      view.getPaddingRight(),</span><br><span class="line">                      view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理器可能只使用一个包含抽象方法的接口或者抽象类，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//kotlin  </span><br><span class="line">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span><br><span class="line">fun setOnLayoutChangeListener(</span><br><span class="line">        view: View,</span><br><span class="line">        oldValue: View.OnLayoutChangeListener?,</span><br><span class="line">        newValue: View.OnLayoutChangeListener?</span><br><span class="line">) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        if (oldValue != null) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">        if (newValue != null) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span><br><span class="line">public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue,</span><br><span class="line">       View.OnLayoutChangeListener newValue) &#123;</span><br><span class="line">  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    if (oldValue != null) &#123;</span><br><span class="line">      view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newValue != null) &#123;</span><br><span class="line">      view.addOnLayoutChangeListener(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以如下在布局中使用你的事件处理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View android:onLayoutChange=&quot;@&#123;() -&gt; handler.layoutChanged()&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>每个监听器只能存在一个方法，因此<strong>如果一个监听器存在多个方法，就必须对其进行拆分</strong>，比方说，<code>View.OnAttachStateChangeListener</code>存在<code>onViewAttachedToWindow(View)</code>和<code>onViewDetachedFromWindow(View)</code>两个方法，<code>Databinding</code>类库就为它们提供了两个区分不同属性的方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// kotlin</span><br><span class="line">// Translation from provided interfaces in Java:</span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">interface OnViewDetachedFromWindow &#123;</span><br><span class="line">    fun onViewDetachedFromWindow(v: View)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">interface OnViewAttachedToWindow &#123;</span><br><span class="line">    fun onViewAttachedToWindow(v: View)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// java</span><br><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewDetachedFromWindow &#123;</span><br><span class="line">  void onViewDetachedFromWindow(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewAttachedToWindow &#123;</span><br><span class="line">  void onViewAttachedToWindow(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为改变一个监听器时会影响到其他的监听器，所以需要让是适配器工作于单个属性或者全部属性这两种情况的一种。而对于这种情况，同样<strong>可以在注解中设置<code>requireAll</code>为<code>false</code>来声明不需要所有属性参数都齐全也能使用</strong>，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin</span><br><span class="line">@BindingAdapter(</span><br><span class="line">        &quot;android:onViewDetachedFromWindow&quot;,</span><br><span class="line">        &quot;android:onViewAttachedToWindow&quot;,</span><br><span class="line">        requireAll = false</span><br><span class="line">)</span><br><span class="line">fun setListener(view: View, detach: OnViewDetachedFromWindow?, attach: OnViewAttachedToWindow?) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        val newListener: View.OnAttachStateChangeListener?</span><br><span class="line">        newListener = if (detach == null &amp;&amp; attach == null) &#123;</span><br><span class="line">            null</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            object : View.OnAttachStateChangeListener &#123;</span><br><span class="line">                override fun onViewAttachedToWindow(v: View) &#123;</span><br><span class="line">                    attach?.onViewAttachedToWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onViewDetachedFromWindow(v: View) &#123;</span><br><span class="line">                    detach?.onViewDetachedFromWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val oldListener: View.OnAttachStateChangeListener? =</span><br><span class="line">                ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener)</span><br><span class="line">        if (oldListener != null) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener)</span><br><span class="line">        &#125;</span><br><span class="line">        if (newListener != null) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line">@BindingAdapter(&#123;&quot;android:onViewDetachedFromWindow&quot;, &quot;android:onViewAttachedToWindow&quot;&#125;, requireAll=false)</span><br><span class="line">public static void setListener(View view, OnViewDetachedFromWindow detach, OnViewAttachedToWindow attach) &#123;</span><br><span class="line">    if (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        OnAttachStateChangeListener newListener;</span><br><span class="line">        if (detach == null &amp;&amp; attach == null) &#123;</span><br><span class="line">            newListener = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newListener = new OnAttachStateChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onViewAttachedToWindow(View v) &#123;</span><br><span class="line">                    if (attach != null) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onViewDetachedFromWindow(View v) &#123;</span><br><span class="line">                    if (detach != null) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener,</span><br><span class="line">                R.id.onAttachStateChangeListener);</span><br><span class="line">        if (oldListener != null) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newListener != null) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例会比正常情况稍微复杂些，因为<code>View</code>是通过<code>addOnAttachStateChangeListener()</code>和<code>removeOnAttachStateChangeListener()</code>方法来设置和移除监听器的，而不是使用<code>set</code>方法。<code>android.databinding.adapters.ListenerUtil</code>类用于追踪上一个监听器，这样就使得旧监听器可以从<code>BindingAdapter</code>中移除。</p><p>通过注解<code>@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</code>可以然让数据绑定代码生成器知道这些方法需要运行在<code>Android 3.1 (API 12)</code>以上版本。</p><h3 id="三、对象转换-Object-conversions"><a href="#三、对象转换-Object-conversions" class="headerlink" title="三、对象转换 (Object conversions)"></a>三、对象转换 (Object conversions)</h3><p><strong>1. 自动转换</strong></p><p>当一个<code>Object</code>从绑定表达式中返回时，<code>Databinding</code>库会选择方法来设置这个属性值，这个<code>Object</code>最终会被转换成<code>set</code>方法对应的参数类型。这种行为在使用<code>ObservableMap</code>类存取数据时会非常方便，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&apos;@&#123;userMap[&quot;lastName&quot;]&#125;&apos;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong> 同样可以使用<code>object.key</code>方式来引用值，例如<strong>上面的<code>@{userMap[&quot;lastName&quot;]}</code>可以替换为<code>@{userMap.lastName}</code></strong>。</p><p>上面<code>userMap</code>对象在表达就是中返回的值会自动转换为<code>setText(CharSequence)</code>方法的参数类型，用于设置<code>android:text</code>属性，<strong>如果参数类型很模糊，那么就必须手动转换表达式的返回值。</strong></p><p><strong>2. 自定义转换</strong></p><p>某些情况下，自定义转换是必要的，例如，<code>View</code>的<code>android:background</code>属性需要一个<code>Drawable</code>类型的数据，而<code>color</code>属性值是个<code>int</code>类型，如果我们给<code>background</code>误传了<code>color</code>的<code>int</code>数据，那么就会出问题了，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @color/red : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><p>每当需要<code>Drawable</code>类型，但实际却是<code>color</code>的<code>int</code>时，那么需要转换成<code>ColorDrawable</code>，通过 <strong><code>@BindingConversion</code>注解</strong> 方法则可以实现这一转换，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// kotlin</span><br><span class="line">@BindingConversion</span><br><span class="line">fun convertColorToDrawable(color: Int) = ColorDrawable(color)</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line">@BindingConversion</span><br><span class="line">public static ColorDrawable convertColorToDrawable(int color) &#123;</span><br><span class="line">    return new ColorDrawable(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而<strong>表达式中返回的类型必须是唯一的，同一个表达式不能存在不同的返回值类型</strong>，如下错误示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是错误的示例--&gt;</span><br><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @drawable/error : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DataBinding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Lifecycle-Aware组件处理生命周期[翻译]</title>
      <link href="/2019/06/02/%E9%80%9A%E8%BF%87Lifecycle-Aware-%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%5B%E7%BF%BB%E8%AF%91%5D/"/>
      <url>/2019/06/02/%E9%80%9A%E8%BF%87Lifecycle-Aware-%E7%BB%84%E4%BB%B6%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%5B%E7%BF%BB%E8%AF%91%5D/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念"></a>引入概念</h4></blockquote><ul><li><p><strong>Lifecycle解决的问题：</strong></p><ul><li>用于响应、管理其他应用组件（如<code>Activity</code>和<code>Fragment</code>）的改变状态，相对于我们自己写事件监听回调接口，<code>Lifecycle</code>会更加简洁、易于管理。</li><li>大部分应用组件都存在于<code>Android Framework</code>，生命周期绑定在此之上，并且直接由系统或者由应用进程框架管理，因此必须遵循它们的规则，避免内存泄露和应用崩溃。</li></ul></li><li><p><strong>实际场景：</strong> 我们需要在<code>Activity</code>中显示设备的位置，通常会这样实现：</p></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyLocationListener &#123;</span><br><span class="line">    public MyLocationListener(Context context, Callback callback) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void start() &#123;</span><br><span class="line">        // connect to system location service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void stop() &#123;</span><br><span class="line">        // disconnect from system location service</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, (location) -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        // manage other components that need to respond</span><br><span class="line">        // to the activity lifecycle</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        // manage other components that need to respond</span><br><span class="line">        // to the activity lifecycle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>貌似看起来很不错，但是在实际应用中，最终会存在太多用于管理其他组件生命周期状态的调用，管理多个组件时会在生命周期方法中放置大量代码，例如 <code>onStart()</code>和<code>onStop()</code>，这使得它们难以维护。</p></li><li><p>此外，无法保证组件在<code>Activity</code>或<code>Fragment</code>停止之前启动,这在我们需要执行耗时长的操作时尤为真实，比如我们在<code>onStart()</code>中检查某些配置，这就可能在当 <code>onStop()</code>在<code>onStart()</code>之间完成的情况下 产生竞争条件，最终导致组件存活的时间比实际需要长。如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, location -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            // what if this callback is invoked AFTER activity is stopped?</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对以上问题，<code>android.arch.lifecycle</code>包提供了可弹性、解耦地解决这些问题的类和接口。</p></li></ul><hr><blockquote><h4 id="Lifecycle的概念"><a href="#Lifecycle的概念" class="headerlink" title="Lifecycle的概念"></a><strong><code>Lifecycle</code>的概念</strong></h4></blockquote><ul><li><p><code>lifecycle</code>是一个持有组件生命周期（<code>Activity</code>，<code>Fragment</code>）状态的类，并且允许其他对象观察这一状态。</p></li><li><p><code>lifecycle</code> 使用两个主要枚举类来处理与之绑定的组件的生命周期状态。</p><ul><li><strong>Event</strong>: 这个事件由系统框架和<code>Lifecyle</code>类分发，并且会映射到<code>Activit</code>和<code>Fragment</code>的回调事件上。</li><li><strong>State</strong>: 代表当前<code>LIfecycle</code>对象正在处理的组件的状态。<br><img src="http://upload-images.jianshu.io/upload_images/5879616-8c30c9527228331d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="思考`States`节点以及`Events`事件"></li></ul></li><li><p>通过给方法添加注解的方式可以使这个类具备监听组件生命周期的能力，然后通过<code>Lifecycle#addObserver()</code>添加观察者即可赋予其他对象这个观察能力，如下示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 作为观察者，我们需要实现 LifecycleObserver 接口</span><br><span class="line">public class MyObserver implements LifecycleObserver &#123;</span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) // 在onResume时执行</span><br><span class="line">    public void connectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) // 在onPause时执行</span><br><span class="line">    public void disconnectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加一个观察者，使得这个观察者也可以监听组件状态变化</span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(new MyObserver());</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><h4 id="LifeOwner的概念"><a href="#LifeOwner的概念" class="headerlink" title="LifeOwner的概念"></a><code>LifeOwner</code>的概念</h4></blockquote><ul><li><p><code>LifeOwner</code>只包含一个<code>getLifecycle()</code>方法，用于获取<code>Lifecycle</code>，使用时必须实现这个方法。<strong>如果想要管理整个应用进程的生命周期，可以使用<code>ProcessLifecycleOwner</code>代替</strong>。</p></li><li><p>这个接口从<code>Activity</code>和<code>Fragment</code>等中抽取了<code>Lifecycle</code>的所有权，并且允许编写组件来与之配合，<strong>任何自定义的应用类都可以实现<code>LifecOwner</code>接口</strong>。</p></li><li><p>实现了<code>LifecycleOwner</code>的组件与实现了<code>LifecycleObserver</code>的组件运作方式是无缝衔接的的，<strong>因为<code>Owner</code>用于提供事件，而<code>Observer</code>用于注册、监听事件</strong>。</p></li></ul><ul><li><p>在前面我们定义了一个实现了<code>LifecycleObserver</code>接口的<code>MyLocationLIstener</code>类，我们可以如下面代码这样在<code>onCreate</code>中初始化，这意味响应生命周期变化的逻辑都提取到了<code>MyLocationLIstener</code>，而不是全部挤在<code>Activity</code>中，可见这样可以极大简化<code>Activity</code>和<code>Fragment</code>的代码逻辑。 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = new MyLocationListener(this, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为了避免在<code>Lifecycle</code>的不合适状态下执行回调，比如如果这个回调用于在<code>Activity</code>保存状态后执行<code>Fragment</code>的转场切换，就会触发崩溃，因此我们千万不要执行这个回调。为了简单处理这个问题，<code>Lifecycle</code>允许其他对象查看当前状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MyLocationListener implements LifecycleObserver &#123;</span><br><span class="line">    private boolean enabled = false;</span><br><span class="line">    public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">    void start() &#123;</span><br><span class="line">        if (enabled) &#123;</span><br><span class="line">           // connect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enable() &#123;</span><br><span class="line">        enabled = true;</span><br><span class="line">        // 查看Lifecycle的当前状态</span><br><span class="line">        if (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            // connect if not connected</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br><span class="line">    void stop() &#123;</span><br><span class="line">        // disconnect if connected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过上面实现，我们的<code>MyLocationListener</code>就完全可以管理生命周期了，如果想要在其他<code>Activity</code>或<code>Fragment</code>中使用它，那么只需要初始化一下就行了，其他处理操作都会在它内部处理。</p></li><li><p>如果一个类库提供需要结合<code>Android</code>生命周期的处理类，那么建议使用<code>Lifecycle-aware</code>组件，这样的话类库客户端就可以轻易地整合这些组件而不需要手动地在客户端处理生命周期管理工作。</p></li></ul></li></ul><ul><li><strong>实现自定义的 LifecycleOwner</strong><ul><li>在<code>Support Library 26.1.0</code>以及上版本中，<code>Fragment</code>和<code>Activity</code>已经实现了<code>LifecycleOwner</code>接口。</li><li>如果需要自定义实现一个<code>LifecycleOwner</code>，那么可以使用<code>LifecycleRegistry</code>类，但是你需要发送事件到<code>LifecycleRegistry</code>类中，如下示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends Activity implements LifecycleOwner &#123;</span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = new LifecycleRegistry(this);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle getLifecycle() &#123;</span><br><span class="line">        return mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><h3 id="lifecycle-aware-组件最佳实践"><a href="#lifecycle-aware-组件最佳实践" class="headerlink" title="lifecycle-aware 组件最佳实践"></a><strong>lifecycle-aware 组件最佳实践</strong></h3></blockquote><ul><li><p><strong>尽可能保证<code>UI</code>控制器，如<code>Activity</code>和<code>Fragment</code>的简洁性</strong>，它们不应该请求它们自身的数据，而应交给<code>ViewModel</code>去做，并观察一个<code>LiveData</code>对象，用来将变化返回给<code>UI</code>视图。</p></li><li><p><strong>尽量编写数据驱动型（<code>data-driven</code>）<code>UI</code></strong>，这种形式下，<code>UI</code>控制器只需要负责在数据改变时更新视图，或者通知用户动作给<code>ViewModel</code></p></li><li><p><strong>将数据逻辑放到<code>ViewModel</code>类，<code>ViewModel</code>应当用作<code>UI</code>控制器和应用其他部分的连接器</strong>，但是注意，<code>ViewModel</code>不负责请求数据（比如网络请求等），相反，它只是调用数据请求模块去请求数据，然后将数据结果返回给<code>UI</code>控制器。</p></li><li><p><strong>使用<code>DataBinding</code>来维持视图与<code>UI</code>控制器间的简洁性</strong>。它可以可简化视图的声明和视图更新时所需在<code>UI</code>控制器中编写的代码，<strong>如果喜欢使用<code>Java</code>，那么建议使用类似于<code>ButterKnife</code>之类的类库来避免编写无聊的声明代码</strong>，并且它可以实现更好的抽象。</p></li><li><p><strong>如果<code>UI</code>很复杂，可以考虑创建一个<code>Presenter</code>类来处理<code>UI</code>更改操作</strong>，这可能很费事，但可以使<code>UI</code>组件更易于测试。</p></li><li><p><strong>禁止在<code>ViewModel</code>中引用<code>View</code>或者<code>Activity</code>上下文（<code>context</code>）</strong>，否则如果<code>ViewModel</code>生命周期比<code>Activity</code>长时（比如<code>configuration change</code>的情况），<code>Activity</code>就会内存泄露而不被<code>GC</code>了。</p></li></ul><hr><blockquote><h3 id="lifecycle-aware-组件使用场景"><a href="#lifecycle-aware-组件使用场景" class="headerlink" title="lifecycle-aware 组件使用场景"></a><strong>lifecycle-aware 组件使用场景</strong></h3></blockquote><p><code>lifecycle-aware</code>组件可以在各种场景中让生命周期的管理更简单，比如以下场景：</p><ul><li><strong>粗略定位（<code>coarse-grained</code>）与高精度定位（<code>fine-grained</code>）之间的更新状态切换</strong>。使用<code>lifecycle-aware</code>组件在应用处于前台时开启高精度定位，而在后台时开启粗略定位，可以结合<code>LiveData</code>来实现状态改变时更新<code>UI</code>的操作。</li><li><strong>开启和关闭视频缓冲。</strong> 比如使用<code>lifecycle-aware</code>组件尽快开启视频缓冲，而延迟到应用完全启动后才真正播放视频，同样也可以在应用关闭时终止缓冲动作。</li><li><strong>开启和关闭网络连接。</strong> 使用<code>lifecycle-aware</code>组件进行动态更新网络数据，如应用处于前台时自动加载数据，而应用切换至后台时自动暂停加载。</li><li><strong>启动和暂停<code>Drawable</code>动画。</strong> 前台时播放动画，后台是暂停动画。</li></ul><hr><blockquote><h3 id="处理-onStop-事件"><a href="#处理-onStop-事件" class="headerlink" title="处理 onStop 事件"></a>处理 onStop 事件</h3></blockquote><p>当<code>Lifecycle</code>关联到<code>AppCompatActivity</code>或<code>Fragment</code>时，它的状态会切换到<code>CREATED</code>，而<code>ON_STOP</code>状态则是会在<code>AppCompatActivity</code>或<code>Fragment</code>的<code>onSaveInstanceState()</code>被调用是触发。</p><p>如果<code>AppCompatActivity</code>或<code>Fragment</code>是通过<code>onSaveInstanceState()</code>中保存状态的，那么在<code>ON_START</code>被调用之前，它们的<code>UI</code>状态都会被认定为不可变的(<code>immutable</code>)。这时如果尝试在<code>UI</code>状态保存后修改<code>UI</code>的话，就会导致应用导航状态不一致，这也就是为什么在状态保存后执行<code>FragmentTransaction</code>，<code>FragmentManager</code>会抛异常的原因了，具体看 <a href="https://developer.android.google.cn/reference/android/support/v4/app/FragmentTransaction#commit()" target="_blank" rel="noopener">commit()方法</a>。</p><p>如果<code>LiveData</code>的已经关联到<code>Lifecycle</code>的<code>Observer</code>还没到到达<code>STARTED</code>状态的话, <code>LiveData</code>可以通过终止<code>observer</code>的调用来避免上述边角情况的发生，这是因为<code>LiveData</code>会在执行<code>Observer</code>之前先调用<code>isAtLeast()</code>确定状态，然后再决定是否执行。</p><p><strong>然而不幸的是，<code>AppCompatActivity</code>的<code>onStop()</code>方法实在<code>onSaveInstanceState()</code>之后调用的，这种情况就导致已经保存的<code>UI</code>状态不允许改变，而<code>Lifecycle</code>又还没有到达<code>STARTED</code>状态。</strong></p><p>为了避免这个问题的发生，在版本<code>beta2</code>及之前的<code>Lifecycle</code>类都会将这一状态标记为<code>CREATED</code>，而不分发这一事件，这样，任何检查当前状态的代码都能拿到真实状态值，即使这一事件还没有被分发，直到系统调用<code>onStop()</code>方法。</p><p><strong>然而又不幸的是，这个解决方案有两大问题：</strong></p><ul><li>在<code>API 23</code>及之前的版本，<code>Android</code>系统确实会保存<code>Activity</code>的状态，即使是由其他<code>AActivity</code>转换的部分，也就是说，系统调用<code>onSaveInstanceState()</code>，但是确实没有调用<code>onStop()</code>必要。这造成了一个潜在的长间隔期，而在这个间隔期之间，<code>observer</code>一直会认为<code>Lifecycle</code>是活动的，即使<code>UI</code>状态已经不能被改变了。</li><li>任何想要暴露给<code>LiveData</code>类似行为的类都必须实现<code>Lifecycle</code>在<code>beta2</code>及之前版本所提供的解决方案。</li></ul><p><strong>Note</strong>: 为了简化流程并兼容老版本，<strong>请直接从版本<code>1.0.0-rc1</code>开始使用</strong>，<code>Lifecycle</code>对象会被标记为<code>CREATED</code>，并且会在<code>onSaveInstanceState()</code>被调用是标记为<code>ON_STOP</code>状态，而无需等待<code>onStop()</code>的调用。虽然这并不会影响我们的代码，但是确是我们需要注意的，因为它没有遵循<code>API 26</code>及以前版本中<code>Activity</code>的生命周期调用次序</p>]]></content>
      
      
      
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5与原生混合开发总结</title>
      <link href="/2019/06/02/H5%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/02/H5%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本文主要针对<code>H5</code>与原生混合开发中的交互问题进行讨论，当然，这仅仅是鄙人的见解，求同存异。</p><p><strong>本文主要针对以下问题进行总结：</strong></p><ol><li>如何实现<code>JS</code>与<code>Andriod</code>的交互？</li><li>针对<code>WebView</code>启动慢问题，如何优化？</li><li>如果存在多个<code>H5</code>模块包，如何实现模块包的完全更新与部分更新？</li><li>针对以上问题的，如何建立一个公用的工具集（框架？）？</li><li>遇到的问题及解决办法。</li></ol><p>OK, 开始吧！</p><a id="more"></a><h3 id="二、交互"><a href="#二、交互" class="headerlink" title="二、交互"></a>二、交互</h3><p>关于如何实现<code>JS</code>与<code>Android</code>交互，其实看官方的<a href="https://developer.android.google.cn/guide/webapps/webview" target="_blank" rel="noopener"> Building web apps in WebView</a> 这篇文章就够了，如果你觉得英文不好理解，那也没关系，因为接下来的内容会覆盖这些技术点。</p><ul><li><strong>交互模型：</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5879616-67d5c23bbd7ff120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交互模型1.png"></p><p>其实这里可以进一步将<code>Webview</code>抽象化，那么就得到了如下图关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-2c6fc764b87deb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交互模型2.png"></p><p>显然这里的问题就是如何实现<code>JsExecutor</code>和<code>JsInterfaces</code>了。</p><p><strong>对于<code>JsExecutor</code>而言（<code>Android</code>调用<code>JS</code>）</strong>，其实是比较固定的写法,比如，如果我们想要动态获取网页中某个标签的<code>html</code>,那么会这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 先假设id参数为content</span><br><span class="line">Stirng elementId = &quot;content&quot;;</span><br><span class="line">String jsCode = &quot;javascript:document.getElementById(\&quot; + elementId +\&quot;).innerHtml&quot;; </span><br><span class="line">webView.evaluateJavascript(jsCode, new ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onReceiveValue(String html) &#123;</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这种写法是固定的，但是方法参数比较多时就比较蛋疼了，拼凑方法名和多个参数是很烦人的，且容易出错，因而我们可以抽象出以下工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author horseLai</span><br><span class="line"> * CreatedAt 2018/10/22 17:42</span><br><span class="line"> * Desc: JS 代码执行器，包含通过WebView执行JS代码的通用方法。</span><br><span class="line"> * Update:</span><br><span class="line"> */</span><br><span class="line">public final class JsExecutor &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;JsExecutor&quot;;</span><br><span class="line">    private JsExecutor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JS方法不带参，且无返回值时用此方法</span><br><span class="line">     *</span><br><span class="line">     * @param webView</span><br><span class="line">     * @param jsCode</span><br><span class="line">     */</span><br><span class="line">    public static void executeJsRaw(@NonNull WebView webView, @NonNull String jsCode) &#123;</span><br><span class="line">        executeJsRaw(webView, jsCode, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JS方法带参，且有返回值时用此方法</span><br><span class="line">     *</span><br><span class="line">     * @param webView</span><br><span class="line">     * @param jsCode</span><br><span class="line">     * @param callback</span><br><span class="line">     */</span><br><span class="line">    public static void executeJsRaw(@NonNull WebView webView, @NonNull String jsCode, @Nullable ValueCallback&lt;String&gt; callback) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">            webView.evaluateJavascript(jsCode, callback);</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            // 注意这里，这种方式没有直接的结果回调，不过可以迂回解决，比如我们可以</span><br><span class="line">            // 执行JS的一个固定的方法，并传入类型参数，然后在JS方法中根据这个类型参</span><br><span class="line">            // 数去匹配方法并执行，执行完成后再调用我们注入的相应回调方法将结果传回</span><br><span class="line">            // 来，这样就可以解决结果回调问题了，如果要适配 Android 4.4 以下的版本则可以这么做。</span><br><span class="line">            webView.loadUrl(jsCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JS方法带参，且有返回值时用此方法</span><br><span class="line">     *</span><br><span class="line">     * @param webView</span><br><span class="line">     * @param methodName</span><br><span class="line">     * @param callback</span><br><span class="line">     * @param params</span><br><span class="line">     */</span><br><span class="line">    public static void executeJs(@NonNull WebView webView, @NonNull CharSequence methodName, @Nullable ValueCallback&lt;String&gt; callback, @NonNull CharSequence... params) &#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;javascript:&quot;)</span><br><span class="line">                .append(methodName)</span><br><span class="line">                .append(&quot;(&quot;);</span><br><span class="line">        if (params != null &amp;&amp; params.length &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">                sb.append(&quot;\&quot;&quot;)</span><br><span class="line">                        .append(params[i])</span><br><span class="line">                        .append(&quot;\&quot;&quot;);</span><br><span class="line">                if (i &lt; params.length - 1)</span><br><span class="line">                    sb.append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;);&quot;);</span><br><span class="line">        Log.i(TAG, &quot;executeJs: &quot; + sb);</span><br><span class="line">        executeJsRaw(webView, sb.toString(), callback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JS方法带参，且无返回值时用此方法</span><br><span class="line">     *</span><br><span class="line">     * @param webView</span><br><span class="line">     * @param methodName</span><br><span class="line">     * @param params</span><br><span class="line">     */</span><br><span class="line">    public static void executeJs(@NonNull WebView webView, @NonNull CharSequence methodName, @NonNull CharSequence... params) &#123;</span><br><span class="line">        executeJs(webView, methodName, null, params);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接将<code>WebView</code>视为我们执行<code>JS</code>代码的工具，如下示例是给<code>H5</code>传递当前网络类型，由于整合了<code>JS</code>代码的拼接过程，因此只需要传入具体方法名称和方法的字符串参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsExecutor.executeJs(webView, &quot;onNetStatusChanged&quot;, netType);</span><br></pre></td></tr></table></figure><ul><li><strong>对于<code>JsInterfaces</code>(<code>JS</code>调用<code>Android</code>)</strong> , 我们需要在我们需要注入的方法前加上注解<code>@JavascriptInterface</code>才能将方法暴露出去，然后将包含此方法的类对象注入进去，如下一个实际场景, <code>H5</code>需要从<code>Android</code>原生中获取用户的账号信息，那么可以这么写：</li></ul><p>先注入包含对应方法的<code>H5JsStorage</code>类对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H5JsStorage h5JsStorage = new H5JsStorage(this, mUser);</span><br><span class="line">webView.addJavascriptInterface(h5JsStorage, &quot;h5JsStorage&quot;);</span><br></pre></td></tr></table></figure><p>其中<code>getUserAccountInfo</code>的声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class H5JsStorage implements IH5JsStorage &#123;  </span><br><span class="line">    </span><br><span class="line">    // ... </span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public String getUserAccountInfo()&#123;</span><br><span class="line">        return String.format(&quot;&#123;\&quot;userAccount\&quot;:\&quot;%s\&quot;, \&quot;password\&quot;:\&quot;%s\&quot;, \&quot;userIncrId\&quot;:\&quot;%s\&quot;, \&quot;orgId\&quot;:\&quot;%s\&quot;&#125;&quot;, mUser.getUserAccount(), mUser.getPassword(), mUser.getUserIncrId(), mUser.getOrgId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是<code>H5</code>与原生交互的交互过程，具体代码在文章末尾会给出<code>GitHub</code>地址。</p><h3 id="三、WebView-启动速度优化、多模块包自动更新"><a href="#三、WebView-启动速度优化、多模块包自动更新" class="headerlink" title="三、WebView 启动速度优化、多模块包自动更新"></a>三、WebView 启动速度优化、多模块包自动更新</h3><p><strong>1. <code>WebView</code>启动速度优化</strong></p><p>我们先来做个实验，<strong>测试一下包含<code>WebView</code>的<code>Activity</code>在优化前后的启动速度</strong>，可以这么做：根据<code>Activity</code>的生命周期，在<code>onCreate</code>的第一行处记录下初始时间，在<code>onStart</code>最后一行记录下结束时间，然后计算时间差，作为衡量启动速度的参照，多次测试，记录时间差。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//---------------------------------------------</span><br><span class="line">// 不做任何处理， Mi6 android 8.0</span><br><span class="line">I/Main2Activity: onStart: total cost:150 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:44 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:33 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:54 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:35 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:34 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:34 ms </span><br><span class="line">//  优化后  初始化耗时</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 131 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 121 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 121 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 117 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 110 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 116 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 116 ms</span><br><span class="line">// 之后耗时</span><br><span class="line">I/Main2Activity: onStart: total cost:26 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:20 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:22 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:17 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:19 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:21 ms</span><br><span class="line"></span><br><span class="line">//---------------------------------------------</span><br><span class="line">// 模拟器 android 9.0</span><br><span class="line">I/Main2Activity: onStart: total cost:292 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:50 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:49 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:54 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:43 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:47 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:39 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:41 ms </span><br><span class="line">// 优化后  初始化耗时</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 177 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 169 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 183 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 159 ms</span><br><span class="line">// 之后 耗时</span><br><span class="line">I/Main2Activity: onStart: total cost:40 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:27 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:34 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:34 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:33 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:30 ms</span><br><span class="line"> </span><br><span class="line">//---------------------------------------------</span><br><span class="line">//  MT6592 android 4.4 不做处理</span><br><span class="line">I/Main2Activity: onStart: total cost:141 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:46 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:43 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:42 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:44 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:46 ms  </span><br><span class="line">// 优化后 初始化耗时</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 182 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 50 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 54 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 53 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 54 ms</span><br><span class="line">I/MyWebViewHolder: prepareWebView: total cost: 56 ms</span><br><span class="line">// 之后耗时</span><br><span class="line">I/Main2Activity: onStart: total cost:36 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:34 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:30 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:31 ms</span><br><span class="line">I/Main2Activity: onStart: total cost:32 ms</span><br></pre></td></tr></table></figure><p>根据以上结果可以看出，优化后要比优化前的启动速度快个<code>10~20</code>秒，且抖动较小。可以注意到其中包含一个叫做<code>prepareWebView</code>的时间差，据此，聪明的你肯定能想到我所谓的优化是做了什么操作。嗯~，其实就是使用<code>WebView</code>之前，在合适的地方和时机先将其初始化，之后复用这个创建好的实例，这里我是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author horseLai</span><br><span class="line"> * CreatedAt 2018/12/10 10:11</span><br><span class="line"> * Desc: 用于持有MyWebView实例，减少每次都重新创建和销毁造成的开销</span><br><span class="line"> * Update:</span><br><span class="line"> */</span><br><span class="line">public final class MyWebViewHolder &#123;</span><br><span class="line">    private static final String TAG = &quot;MyWebViewHolder&quot;;</span><br><span class="line"></span><br><span class="line">    private MyWebView mWebView;</span><br><span class="line">    private static MyWebViewHolder sMyWebViewHolder;</span><br><span class="line">    private View pageNoneNet;</span><br><span class="line">     private boolean mShouldClearHistory = false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean shouldClearHistory() &#123;</span><br><span class="line">        return mShouldClearHistory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouldClearHistory(boolean shouldClearHistory) &#123;</span><br><span class="line">        this.mShouldClearHistory = shouldClearHistory;</span><br><span class="line">    &#125;</span><br><span class="line">    private MyWebViewHolder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyWebViewHolder getHolder() &#123;</span><br><span class="line">        if (sMyWebViewHolder != null) return sMyWebViewHolder;</span><br><span class="line"></span><br><span class="line">        synchronized (MyWebViewHolder.class) &#123;</span><br><span class="line">            if (sMyWebViewHolder == null) &#123;</span><br><span class="line">                sMyWebViewHolder = new MyWebViewHolder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sMyWebViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 务必在使用WebView前调用此方法进行初始化</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     */</span><br><span class="line">    public void prepareWebView(Context context) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        if (mWebView != null) return;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mWebView == null) &#123;</span><br><span class="line">                mWebView = new MyWebView(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, &quot;prepareWebView: total cost: &quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);</span><br><span class="line">        Log.d(TAG, &quot;prepare MyWebView OK...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyWebView getMyWebView() &#123; </span><br><span class="line">        return mWebView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void detach() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            Log.d(TAG, &quot;detach MyWebView, but not destroy...&quot;);</span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.removeAllViews();</span><br><span class="line">            mWebView.clearAnimation();</span><br><span class="line">            mWebView.clearFormData();</span><br><span class="line">            // mWebView.clearHistory();</span><br><span class="line">            mShouldClearHistory = true;</span><br><span class="line">            mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void attach(ViewGroup parent, int index) &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            Log.d(TAG, &quot;attach MyWebView, index of ViewGroup is &quot; + index);</span><br><span class="line"></span><br><span class="line">            WebSettings settings = mWebView.getSettings();</span><br><span class="line">            // 不加此配置会无法加载显示界面</span><br><span class="line">            settings.setDomStorageEnabled(true);</span><br><span class="line">            settings.setSupportZoom(false);</span><br><span class="line">            settings.setJavaScriptEnabled(true);</span><br><span class="line">            settings.setUseWideViewPort(true);</span><br><span class="line"></span><br><span class="line">            mWebView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</span><br><span class="line">            mWebView.setVerticalScrollBarEnabled(false);</span><br><span class="line">            mWebView.setHorizontalScrollBarEnabled(false);</span><br><span class="line"></span><br><span class="line">            // 在WebView上层覆盖一个用于提示如错误等信息的布局层，</span><br><span class="line">            FrameLayout frameLayout = new FrameLayout(parent.getContext());</span><br><span class="line">            frameLayout.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</span><br><span class="line">            frameLayout.addView(mWebView, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</span><br><span class="line">            pageNoneNet = LayoutInflater.from(parent.getContext()).inflate(R.layout.layout_null_net, frameLayout, false);</span><br><span class="line">            frameLayout.addView(pageNoneNet);</span><br><span class="line">            pageNoneNet.setVisibility(View.GONE);</span><br><span class="line">            pageNoneNet.findViewById(R.id.btn_try).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    pageNoneNet.setVisibility(View.GONE);</span><br><span class="line">                    mWebView.reload();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            parent.addView(frameLayout, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showNoneNetPage() &#123;</span><br><span class="line">        if (pageNoneNet != null)</span><br><span class="line">            pageNoneNet.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">    public void hideNoneNetPage() &#123;</span><br><span class="line">        if (pageNoneNet != null)</span><br><span class="line">            pageNoneNet.setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void attach(ViewGroup parent) &#123;</span><br><span class="line">        attach(parent, parent.getChildCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            Log.d(TAG,&quot;destroy MyWebView...&quot;);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pause() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            Log.d(TAG,&quot;pause MyWebView...&quot;);</span><br><span class="line">            mWebView.onPause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void resume() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            Log.d(TAG,&quot;resume MyWebView...&quot;);</span><br><span class="line">            mWebView.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeJSInterfaces(String... names) &#123;</span><br><span class="line">        if (names == null || names.length == 0) return;</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            Log.d(TAG,String.format(&quot;removeJSInterfaces:: %s ..&quot;, name));</span><br><span class="line">            mWebView.removeJavascriptInterface(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在合适的地方初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123; </span><br><span class="line">    // ...</span><br><span class="line">    MyWebViewHolder.getHolder().prepareWebView(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到布局中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout parent= findViewById(R.id.parent);</span><br><span class="line">MyWebViewHolder.getHolder().attach(parent);</span><br></pre></td></tr></table></figure><p>在<code>onDestroy</code>时从界面中解除绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    MyWebViewHolder.getHolder().detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 多模块包自动更新</strong></p><p>支持多模块自动更新的目的是方便更新维护，减少用户升级所带来的流量开支，每个模块包之间可以是相互独立的，也方便于团队开发，仅需要和前端约定好文件目录即可。</p><p>先来看看<code>H5</code>模块的自动更新流程（<strong>完整更新</strong>）:<br><img src="https://upload-images.jianshu.io/upload_images/5879616-a22f4dee92a33a95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="H5模块完整包更新流程.png"></p><p>上面是模块包的完整更新过程，还可以进行<strong>补丁更新</strong>，而所谓补丁更新就是，下载的更新包中仅仅包含需要更新的文件，因而对应于上面流程而言，就是少了<strong>删除本地旧版本文件</strong>的过程，而直接解压替换对应文件。这种更新方式有以下优缺点：</p><ol><li>可以极大的减少更新时对用户的流量消耗，且速度极快。</li><li>但是需要前端明确抽取所更新的文件，否则会出现问题，可能这个过程会繁琐点。</li><li>如果使用类似于<code>VueJs</code>这种模板框架编写的界面，因为需要编译为<code>JS</code>代码，然后仅剩一个<code>index.html</code>入口，导致抽取定位繁琐，且每次编译出来的文件名可能不一样，因此不能使用<strong>补丁更新</strong>这种方式，只能分包，然后进行完整更新。</li></ol><p>具体代码比较多，就补贴了，请看 <a href="https://github.com/horseLai/H5MixDevelopTools/blob/master/src/main/java/com/example/roz_h5tools_module/sdk/H5Manager.java" target="_blank" rel="noopener">github这里</a>， 其中<code>H5ManagerSettings</code>是<code>H5Manager</code>配置信息与无关逻辑的抽离类。</p><h3 id="四、建立公用工具集"><a href="#四、建立公用工具集" class="headerlink" title="四、建立公用工具集"></a>四、建立公用工具集</h3><p>上面已经逐个介绍了混合开发中交互与更新的逻辑，工具集已经放到 <code>github</code>的<a href="https://github.com/horseLai/H5MixDevelopTools.git" target="_blank" rel="noopener">H5MixDevelopTools</a>，感兴趣的童鞋可以看看，虽然这里我并没有把<code>JS</code>接口和<code>html</code>界面放上去。<br><img src="https://upload-images.jianshu.io/upload_images/5879616-0b9ebf653c1b6720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="混合开发工具集.png"></p><p><strong>遇到的实际问题与解决办法：</strong>（以项目中使用<code>VueJs</code>作为模板引擎来编写<code>H5</code>页面为例）</p><p><strong>1. 界面加载不出来，显示空白，怎么办？</strong></p><p><strong>解决办法</strong>：给<code>WebView</code>加上下面配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.getSettings().setDomStorageEnabled(true);</span><br></pre></td></tr></table></figure><p><strong>2. 联调时发现总是找不到定义的交互接口方法，怎么办？</strong></p><p><strong>原因与解决办法</strong>：首先，默认情况下，<code>VueJs</code>在对代码进行混淆处理，因此如果你遇到了这个问题，那么请手动配置以关闭混淆（具体做法请自行查找吧）。如果已经不混淆了，但是依然找不到对应的方法，怎么办？我和我的小伙伴是将接口文件放到<code>components</code>中将其视作一个组件来使用的，然后具体到接口方法的话，将方法挂到<code>window</code>对象下，如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 挂载方法</span><br><span class="line">window.showToast = function(msg)&#123;</span><br><span class="line">      UI.showToast(msg);</span><br><span class="line">&#125; </span><br><span class="line">// 挂载变量，挂载在window的变量可以在全局直接引用</span><br><span class="line">window.userInfo = &#123;name:&quot;horseLai&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 图片选择问题，怎么选择和预览图片？</strong></p><p><strong>先来个具体场景</strong>：比如说我们项目中有个评论功能，这个功能是用<code>H5</code>写的，然后每次评论时可以选择数量小于3张的评论图片，附带文字上传至服务器。</p><p>此时你会发现直接使用<code>&lt;input type=&quot;file&quot;&gt;</code>没法调用起系统相片图库和相机，更没法在旁边显示预览图，这时你可能需要这些配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settings.setJavaScriptEnabled(true); </span><br><span class="line">settings.setAllowFileAccess(true);</span><br><span class="line">settings.setAllowFileAccessFromFileURLs(true);</span><br><span class="line">settings.setAllowUniversalAccessFromFileURLs(true);</span><br><span class="line">settings.setAllowContentAccess(true);</span><br></pre></td></tr></table></figure><p>接着就是<strong>选择图片有两种方案</strong>：</p><ul><li>通过复写<code>WebChromeClientc#onShowFileChooser</code>和<code>WebChromeClient#openFileChooser</code>,但是<code>openFileChooser</code>方法已经变为系统<code>Api</code>了，所以没法直观的找到它，但是，即使找到了，你也会发现去适配不同的机型也是坑的很。可以先看看 <a href="https://stackoverflow.com/questions/23568792/android-4-4-webview-file-chooser-not-opening" target="_blank" rel="noopener">android-4-4-webview-file-chooser-not-opening</a>, 而因为我不是直接调用图库选择，而是先开启一个<code>BottomSheetDialog</code>来选择是通过相机还是图库取图，这样带来的问题就是，<strong>如果我仅仅是开启了<code>BottomSheetDialog</code>，然后不做任何选择地关闭掉它，不调用<code>ValueCallback#onReceiveValue</code>传值的话，那么<code>&lt;input&gt;</code>只能启当一次弹窗，之后再点就没反应了，而如果我每次关闭<code>BottomSheetDialog</code>时通过<code>ValueCallback#onReceiveValue</code>传个<code>null</code>，那么连续启动两次后又会异常闪退</strong>，嗯，这坑我就不跳了，我选择第二种方案。</li><li>第二种方案就是直接建立<code>JS</code>交互接口，点击图片选择控件后调用建立好的原生图片选择接口取图，当我们选好图之后在<code>onActivityResult</code>方法中执行<code>JS</code>方法将图片的本地路径传给<code>JS</code>处理，嗯，到这里的话好说，这个流程咱都熟悉。那么来说说如何在<code>&lt;img&gt;</code>上预览，以及如何将这个路径的图片作为文件上传。</li></ul><p>下面是选完图片后我们将图片路径回调到<code>JS</code>的方法。</p><pre><code>/** *  相册中获取图片、相机拍照结果回调 * @param {Number} type   类型： 0-&gt;图库， 1-&gt;相机 * @param {String} imgFilePath   */window.selectedImgFile = [];  // 模拟&lt;input&gt;选择文件后的存储形式，用于上传window.selectedImgFileUrls = []; // 将图片路径转换成&lt;img&gt;能够预览的路径window.onPictureResult = function (type, imgFilePath) {    // 注意这里    selectedImgFile.push(new File([&quot;&quot;], imgFilePath, {type:&quot;image/*&quot;}));    selectedImgFileUrls.push({        imgUrl: &quot;file://&quot; + imgFilePath    });}</code></pre><p>上面<code>selectedImgFile</code>,<code>selectedImgFileUrls</code>这两个挂载到<code>window</code>的变量，这两个数组可以直接在全局引用了，记得在使用后清空，不然会影响到下次使用。</p><p>嗯，看起来很完美，选图、预览很完美，但很快你就会发现这实际是个<code>BUG</code>，<code>BUG</code>在哪里呢？注意到上面的<code>new File([&quot;&quot;], imgFilePath, {type:&quot;image/*&quot;})</code>，这么使用会导致上传到服务器的图片大小为 <code>0kb</code>， 为啥呢？因为第一个参数<code>[&quot;&quot;]</code>实际是图片的实际数据（字节数组），它的长度代表着文件的大小，因此，上面这样做虽然能够预览，但是无法仅仅直接通过一个本地路径就读取到文件流数据，也就不能上传成功了。</p><p>怎么办呢？思考了很久，发现自己一直困在<code>JS</code>如何通过一个本地路径建立<code>File</code>并上传的思维当中，于是找前端和后台的小伙伴交流，最终确定的方案是：选择图片后先将图片编码成<code>Base64</code>字符串再注入到<code>JS</code>处理，<code>JS</code>端收到数据后进行图片数据绑定，以及上传到服务器，服务器端进行<code>Base64</code>解码处理，然后保存成本地图片。</p><p>于是可以稍微修改成这样：</p><pre><code>window.selectedImgFile = [];  window.selectedImgFileUrls = []; // 将图片路径转换成&lt;img&gt;能够预览的路径window.onPictureResult = function (type, imgFilePath, base64Data) {    selectedImgFile.push( base64Data );    selectedImgFileUrls.push({        imgUrl: &quot;data:image/jpg;base64,&quot; + base64Data    });}</code></pre><p>不过这里依然可能存在一些问题，比如内存溢出，因为图片本身可能很大，尤其是使用相机直接拍照取图的情况，一张图片可能会有<code>3~10M</code>，直接编码为图片本身会比较耗时，而编码出来的字符串会存在于内存中，因此很有可能会导致<code>Android</code>端出现内存溢出的情况，因此这里可以考虑先压缩后编码，这样可以降低内存耗尽的几率。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>本文基于实际项目，介绍了混合开发中<code>JS</code>与原生交互的实现，然后以一个小实验测试了含<code>WebView</code>的<code>Activity</code>的启动速度，优化，然后测试优化后的启动速度，接着介绍了<code>H5</code>分模块更新的逻辑，最后整理了一套工具集，感兴趣的童鞋可以看看 <a href="https://github.com/horseLai/H5MixDevelopTools.git" target="_blank" rel="noopener">H5MixDevelopTools</a>，欢迎指正。</p><p>使用<code>H5</code>混合开发确实能够提升开发速度，但是实际体验确实一般，适合非常追求开发速度的场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 进程间通信</title>
      <link href="/2019/06/02/Android-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/06/02/Android-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>关于<code>Android</code>中的进程间通信，我们知道大概可以通过以下方式进行：</p><ul><li><code>Bundle</code>：四大组件间通信</li><li><code>File</code>：文件共享</li><li><code>ContentProvider</code>：应用间数据共享</li><li><code>AIDL</code>：<code>Binder</code>机制</li><li><code>Messager</code>：基于<code>AIDL</code>、<code>Handler</code>实现</li><li><code>Socket</code>：建立<code>C/S</code>通信模型</li></ul><p><strong>本文主要探索的是<code>AIDL</code>和<code>Socket</code>两种实现方式</strong>，并在日常使用的基础上根据<code>AIDL</code>所生成的代码分析 <code>Binder</code>跨进程通信机制，感兴趣的童鞋可以看看。</p><p>本文完整代码：<a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a></p><a id="more"></a><h3 id="二、使用-AIDL和-Socket-进行通信"><a href="#二、使用-AIDL和-Socket-进行通信" class="headerlink" title="二、使用 AIDL和 Socket 进行通信"></a>二、使用 <code>AIDL</code>和 <code>Socket</code> 进行通信</h3><p>先来说说我们一会儿要实现的通信模型，大致如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f53350287d6fac66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要实现的通信模型"></p><p>然后看看目录结构：<br><img src="https://upload-images.jianshu.io/upload_images/5879616-dc67447c3d62653d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件路径"></p><p>再看看<code>IMyAidlInterface.aidl</code>，这里在定义方法名称的时候需要注意的是<strong>方法不能同名，包需要手动导入</strong>，可能是因为<code>AIDL</code>文件在解析时不会区分参数类型，导致我在设定同名方法时一直编译错误，搞得我一直找其他问题，所以这点需要注意一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line"><span class="comment">// 需要手动导入的包</span></span><br><span class="line"><span class="keyword">import</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterfaceCallback;</span><br><span class="line"><span class="keyword">import</span> com.project.horselai.bindprogressguarddemo.MyMessage;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageObj</span><span class="params">(in MyMessage msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerCallback</span><span class="params">(IMyAidlInterfaceCallback callback)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterCallback</span><span class="params">(IMyAidlInterfaceCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>IMyAidlInterfaceCallback.aidl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterfaceCallback.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterfaceCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onValueCallback</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>MyMessage.aidl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyMessage.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.project.horselai.bindprogressguarddemo;</span><br><span class="line"></span><br><span class="line">parcelable MyMessage;</span><br></pre></td></tr></table></figure><p>其他代码太长就不贴出来了，具体请查看 <a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a>。</p><p>演示图如下，具体还是跑起来看看吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-b48b47ff8b940623.gif?imageMogr2/auto-orient/strip" alt="演示.gif"></p><p> <img src="https://upload-images.jianshu.io/upload_images/5879616-5644504702a70c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出信息"></p><p>这里有个现象就是，<code>unbindService</code> 调用之后，<code>ServiceConnection</code> 并没有中断，因此，如果此时再次发送消息也是能够发送和接收到的。</p><h3 id="三、从AIDL生成类源码角度理解Binder机制"><a href="#三、从AIDL生成类源码角度理解Binder机制" class="headerlink" title="三、从AIDL生成类源码角度理解Binder机制"></a>三、从<code>AIDL</code>生成类源码角度理解<code>Binder</code>机制</h3><p><strong>1. 先来点关于 IBinder 的理论知识</strong></p><p>官方原文：<a href="https://developer.android.google.cn/reference/android/os/IBinder.html?hl=zh-cn" target="_blank" rel="noopener">IBinder</a></p><p><code>IBinder</code>作为远程对象的基础接口，是为高性能执行跨进程和进程内调用设计的轻量级远程调用机制的核心部分，它描述了与远程对象交互时的抽象协议，使用时应该继承 <code>Binder</code>，而应直接实现 <code>IBinder</code>接口。</p><p><code>IBinder</code>的关键 <code>API</code>是 <code>transact()</code>，它与 <code>Binder.onTranscat()</code>配对使用，当调用<code>transcat()</code>方法时会发送请求到<code>IBinder</code>对象，而接收到请求时是在<code>Binder.onTranscat()</code>中接收，<code>transcat()</code>是同步执行的，执行<code>transcat()</code>后<code>transcat()</code>会等待对方<code>Binder.onTranscat()</code>方法返回后才返回，这种行为在同一进程中执行时是必然的，而在不同进程间执行时，底层<code>IPC</code>机制也会确保具备与之相同的行为。</p><p><code>transact()</code>方法发送的是<code>Parcel</code>类型的数据，<code>Parcel</code>是一种通用数据缓冲，它包含一些描述它所承载内容的元数据(<code>meta-data</code>)，这些元数据用于管理缓冲数据中的<code>IBinder</code>对象引用，因此这些引用可以被保存为缓冲数据而传递到其他进程。这种机制保证了<code>IBinder</code>能够被写入<code>Parcel</code>中并发送到其他进程，如果其他进程发送相同的<code>IBinder</code>引用回来给源进程，则说明源进程收到一个相同的<code>IBinder</code>对象，这种特性使<code>IBinder/Binder</code>对象能够作为进程间的唯一标识（作为服务器<code>token</code>或者其他目的）。</p><p>系统会为每个运行的进程维护一个事务线程池，线程池中的线程用于分发所有来自其他进程的<code>IPC</code>事务，例如，当进程<code>A</code>与进程<code>B</code>进行<code>IPC</code>时（此时<code>A</code>为发送进程），由于<code>A</code>调用<code>transact()</code>发送事务到进程<code>B</code>的缘故，<code>A</code>中被调用的线程会被阻塞在<code>transact()</code>，此时如果<code>B</code>进程中的可用线程池线程接收到了来自<code>A</code>的事务，就会调用目标对象（<code>A</code>进程）的<code>Binder.onTranscat()</code>，并回复一个<code>Parcel</code>作为应答。接收到来自<code>B</code>进程的应答后，在<code>A</code>进程中执行<code>transact()</code>的线程就会结束阻塞，从而继续执行其他逻辑。</p><p><code>Binder</code>系统同样支持跨进程递归，例如，如果进程<code>A</code>执行一个事务到进程<code>B</code>，然后进程<code>B</code>处理接收到的事务时又执行了由进程<code>A</code>实现的<code>IBinder.transact()</code>，那么进程<code>A</code>中正在等待原事务执行结束的线程将用于执行由进程<code>B</code>调用的对象的<code>Binder.onTranscat()</code>应答。这种行为保证了递归机制在远程调用<code>Binder</code>对象和本地调用时行为一致。</p><p><strong>通过以下三种方式可以确定远程对象是否可用：</strong></p><ul><li>当调用一个不存在进程的<code>IBinder.transact()</code>时会抛出<code>RemoteException</code>异常；</li><li>调用<code>pingBinder()</code>返回<code>false</code>时表示远程进程已经不存在；</li><li>使用<code>linkToDeath()</code>方法给<code>IBinder</code>注册一个<code>IBinder.DeathRecipient</code>，那么当其承载进程被杀死时会通过这个监听器通知；</li></ul><p><strong>2. AIDL 生成类源码分析</strong></p><p>先来看看生成类的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-c4f67681c4e902e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成类的结构"></p><p>其中<code>IMyAidlInterface</code>接口是我们定义<code>AIDL</code>接口的直接代码生成，而<code>IMyAidlInterface.Stub</code>则是实现<code>IMyAidlInterface</code>接口的抽象类，实现了<code>onTranscat()</code>方法，不过它并没有具体实现<code>IMyAidlInterface</code>的方法，而是将这部分的实现交给了<code>IMyAidlInterface.Stub.Proxy</code>。</p><p>OK，我们来具体分析一下。首先定位到<code>Stub#asInterface</code>，可见它主要负责区分当前进行的是本地通信还是跨进程通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.project.horselai.bindprogressguarddemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 查找本地是否存在这个 IBinder 对象</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="comment">// 如果是本地通信，则稍后进行本地通信</span></span><br><span class="line">        <span class="keyword">return</span> ((com.project.horselai.bindprogressguarddemo.IMyAidlInterface) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 否则，稍后使用这个对象进行远程通信</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.project.horselai.bindprogressguarddemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来看看<code>Stub#onTranscat</code>方法， 各参数作用如下</p><ul><li><strong>code：</strong> 标识需要执行的动作，是一个从<code>FIRST_CALL_TRANSACTION</code>到<code>LAST_CALL_TRANSACTION</code>之间的数字。</li><li><strong>data：</strong> <code>transcat()</code>调用者发送过来的数据。</li><li><strong>reply：</strong> 用于给<code>transcat()</code>调用者写入应答数据。</li><li><strong>flags：</strong> 如果是 <code>0</code>，代表是一个普通<code>RPC</code>，如果是<code>FLAG_ONEWAY</code>则代表是一个<code>one-way</code>类型的<code>RPC</code>。</li><li><strong>return：</strong> 返回<code>true</code>代表请求成功了，返回<code>false</code>则表示你没有明白事务代码（<code>code</code>）。</li></ul><p>基于前面的理论知识，我们已经知道进程<code>A</code>中的<code>onTransact()</code>会被进程<code>B</code>调用，用于远程回调应答数据，下面通过两个标志性的方法解释在<code>onTransact()</code>中都做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="comment">// 对于远程写请求</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_sendMessage: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            java.lang.String _arg0;</span><br><span class="line">            <span class="comment">// 1. 从进程A的远程请求包中读取请求数据</span></span><br><span class="line">            _arg0 = data.readString();</span><br><span class="line">            <span class="comment">// 2. 执行进程B中的sendMessage方法写入来自进程A的数据</span></span><br><span class="line">            <span class="keyword">this</span>.sendMessage(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于远程读请求</span></span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getProcessId: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            <span class="comment">// 1. 执行进程B中的getProcessId() 读取需要作为响应数据的数据</span></span><br><span class="line">            <span class="keyword">int</span> _result = <span class="keyword">this</span>.getProcessId();</span><br><span class="line">            <span class="comment">// 2. 将读取到的响应数据写入到进程A的应答中</span></span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你会对上面的<code>this.sendMessage(_arg0)</code>和<code>this.getProcessId()</code>有所疑问，比如，为什么在<code>TRANSACTION_sendMessage</code>中还要执行<code>this.sendMessage(_arg0)</code>，这不就死循环了吗？ 不会的，为啥呢，因为<code>TRANSACTION_sendMessage</code>判断的是来自进程<code>A</code>的方法类型码，而在解析了来自进程<code>A</code>的请求参数<code>data</code>后会调用进程<code>B</code>自身的<code>sendMessage(_arg0)</code>方法将数据保存到自己的存储内存中，而它的<code>sendMessage(_arg0)</code>是有我们自己实现的，如下是我们在进程<code>B</code>中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMyAidlInterface.Stub myAidlInterface = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"sendMessage: "</span> + msg);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.myPid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这是不是就很好理解了。</p><p>下面通过<code>Proxy#sendMessage</code>和<code>Proxy#getProcessId</code>两个与上面对应的方法来解释作为客户端的进程<code>A</code>是如何给远程作为服务端的<code>B</code>进程发送请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(java.lang.String msg)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); <span class="comment">// 请求参数</span></span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); <span class="comment">// 响应数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 封装远程请求参数</span></span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(msg);</span><br><span class="line">        <span class="comment">// 2. 通过Binder执行远程请求，最终响应数据会封装在_reply</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3. 没有需要返回数据则仅读取异常</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProcessId</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain(); <span class="comment">// 请求参数</span></span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain(); <span class="comment">// 响应数据</span></span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 没有参数，则仅写入标识</span></span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">// 2. 通过Binder执行远程请求，最终响应数据会封装在_reply</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getProcessId, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3. transact阻塞结束后读取响应数据</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，实际上<code>_reply</code>一直使用的都是同一个，由进程<code>A</code>创建，发送给<code>B</code>进程，进程<code>B</code>会将处理好的响应数据写入到<code>_reply</code>中，并最终通过<code>onTranscat</code>方法回调给进程<code>A</code>，这样就完成了一个<code>RPC</code>。</p><p>总的来说，整个过程的执行流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/5879616-c1e546e703174f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Binder进行IPC"></p><h3 id="四、Messenger使用与源码分析"><a href="#四、Messenger使用与源码分析" class="headerlink" title="四、Messenger使用与源码分析"></a>四、<code>Messenger</code>使用与源码分析</h3><p><strong>1. 使用</strong></p><p>在<code>Service</code>进程中如下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerRemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerRemoteService"</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用 Messenger 进行进程间通信</span></span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"handleMessage: "</span> + msg);</span><br><span class="line">                Log.i(TAG, <span class="string">"handleMessage data: "</span> + msg.getData().get(<span class="string">"msg"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>Activity</code>中如下建立服务连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Messenger</span></span><br><span class="line"><span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">ServiceConnection mServiceConnection3 = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onServiceConnected3: "</span>);</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        btnBindRemote.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mIsBond = <span class="keyword">true</span>;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"service bond 3!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onServiceDisconnected 3: "</span>);</span><br><span class="line">        mIsBond = <span class="keyword">false</span>;</span><br><span class="line">        btnBindRemote.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>绑定后如下发送信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>)&#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    bundle.putString(<span class="string">"msg"</span>,<span class="string">"message  clicked from Main .."</span>);</span><br><span class="line">    message.what = <span class="number">122</span>;</span><br><span class="line">    message.setData(bundle);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMessenger.send( message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-560c9a9e1d25a1c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="日志输出"></p><p>基于上面的使用，整个流程下来你会发现<code>Messenger</code>的通信是单向的，如果想要双向的话，那么需要在作为客户端的进程<code>A</code>上也创建一个<code>Messenger</code>和<code>Handler</code>，然后在<code>B</code>进程中发送响应消息。</p><p>为了能够进行双向通信，我们可以对上面代码进行如下修改，其中<code>MessengerRemoteService</code>中的<code>Messenger</code>可以这么修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"handleMessage: "</span> + msg);</span><br><span class="line">        Log.i(TAG, <span class="string">"handleMessage data: "</span> + msg.getData().get(<span class="string">"msg"</span>));</span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.replyTo = mMessenger;</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">"msg"</span>, <span class="string">"MSG from MessengerRemoteService.."</span>);</span><br><span class="line">        message.setData(bundle);</span><br><span class="line">        message.what = <span class="number">124</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注意这里</span></span><br><span class="line">            msg.replyTo.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>注意到上面的<code>msg.replyTo.send(message)</code>，其中<code>msg.replyTo</code>是一个代表发送这个消息的<code>Messenger</code>。在<code>Activity</code>中可以这么改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onCreate中</span></span><br><span class="line">mClientMessenger = <span class="keyword">new</span> Messenger(mHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper(), <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">2</span>) &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">""</span> + msg.obj, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg.what == <span class="number">124</span>)&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>,   msg.getData().getString(<span class="string">"msg"</span>), Toast.LENGTH_SHORT).show();</span><br><span class="line">            Log.i(TAG, <span class="string">"handleMessage: "</span> + msg.getData().getString(<span class="string">"msg"</span>));</span><br><span class="line">            Log.i(TAG, <span class="string">"handleMessage: "</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        textView.setText(String.valueOf(msg.obj));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后<code>Activity</code>收到消息时会弹出收到的消息，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-d6b681bc8d4ef7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收到MessengerRemoteService消息"></p><p>整个双向通信的流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-f120f2f156a75086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Messenger双向通信"></p><p><strong>2. Messenger 实现原理</strong></p><p>Messenger底层仅仅是简单地包裹了一下<code>Binder</code>，具体来说就是也使用的<code>AIDL</code>，因此它不会影响到进程的生命周期，不过当进程销毁时，连接也会中断。</p><p>下面来简要看一下它的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">        mTarget = target.getIMessenger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">        mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>IMessenger</code>是个<code>AIDL</code>接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os; </span><br><span class="line"><span class="keyword">import</span> android.os.Message; </span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的知识基础，这玩意儿就很好理解了。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>本文主要描述了<code>Android</code>进程间通信中的<code>AIDL</code>和<code>Socket</code>两种方式，文中没有对<code>Socket</code>方式做过多描述和分析，是因为使用<code>Socket</code>通信是比较基础的事情，并且它的实现过程相对容易理解，因此就一笔带过了，具体实现源码请查看 <a href="https://github.com/horseLai/AndroidIPCDemo" target="_blank" rel="noopener">AndroidIPCDemo</a>。文中着重从<code>AIDL</code>生成源码角度分析了<code>Binder</code>的运行机制，并简单介绍了<code>Messenger</code>的使用及其实现。</p><p>OK，水平有限，欢迎理性指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再读Handler机制</title>
      <link href="/2019/06/02/%E5%86%8D%E8%AF%BBHandler%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/06/02/%E5%86%8D%E8%AF%BBHandler%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><blockquote><p>距离上一次阅读<code>Handler</code>源码已经半年多过去了，当时读源码的目的更多的是忙于毕业找工作，为面试做准备，现在则是想更多地了解<code>Android</code>相关机制。半年多过去了，回头看当时的源码解读笔记（当时不写博客），发现有很多地方并没有很好地解释清楚，于是想趁着这2018结束之际再次根据自己的想法整理一遍，感兴趣的童鞋可以看看。</p></blockquote><p>所谓<code>Handler</code>机制，实际是线程切换机制。在我们日常开发中用的最多的是通过<code>Handler</code>来更新<code>UI</code>视图，而<code>Handler</code>除了用于线程切换外，<code>Handler</code>、<code>Looper</code>、<code>ThreadLocal</code>、<code>MessageQueue</code>、<code>Message</code>如何融合、构成一个成熟框架的思想更值得我们学习，这也是写本文的目的：比较深入全面地理解<code>Handler</code>机制。</p><h3 id="二、预热知识"><a href="#二、预热知识" class="headerlink" title="二、预热知识"></a>二、预热知识</h3><p>通常，我们使用<code>Handler</code>是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler1;</span><br><span class="line"></span><br><span class="line"> mHandler1 = new Handler(new Handler.Callback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean handleMessage(Message msg) &#123;</span><br><span class="line">            // 操作 UI</span><br><span class="line">            textView.setText(String.valueOf(msg.obj));</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>又如这样手动建立一个消息循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler;</span><br><span class="line">Looper mLooper;</span><br><span class="line">private void createHandlerLoop() &#123;</span><br><span class="line">   Thread looperThread =  new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            mHandler = new Handler(new Handler.Callback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean handleMessage(Message msg) &#123;</span><br><span class="line">                    // 操作UI时异常</span><br><span class="line">                    // Looper不执行于UI线程，不能直接操作View控件</span><br><span class="line">                    // textView.setText(String.valueOf(msg.obj));</span><br><span class="line">                    Toast.makeText(MainActivity.this, String.valueOf(msg.obj), Toast.LENGTH_SHORT).show();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    looperThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们给两个<code>Handler</code>发送消息，这里我们从非主线程发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ExecutorService mExecutorService = Executors.newCachedThreadPool();</span><br><span class="line">public void sendMessage(View view) &#123;</span><br><span class="line">    mExecutorService.submit(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mHandler != null) </span><br><span class="line">                mHandler.obtainMessage(1, &quot;&quot; + Math.random()).sendToTarget(); </span><br><span class="line">            if (mHandler1 != null) </span><br><span class="line">                mHandler1.obtainMessage(1, &quot;`from mHandler1::&quot; + Math.random()).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>Handler</code>运行于<code>Looper</code>，而<code>Looper</code>运行于创建它的线程中，因此可以说<code>Handler</code>运行于创建它的线程，这里刚好验证一下，我们给<code>mHandler1</code>和<code>mHandler</code>发消息，然后在其中更新<code>UI</code>，此时<code>mHandler1</code>正常更新，而<code>mHandler</code>则报非主线程更新<code>UI</code>的异常，可见 <code>mHandler1</code>的<code>Looper</code>运行于主线程，而<code>mHander</code>则运行于<code>looperThread</code>。</p><p>当然，这些只是表象上，我们来看看为啥它运行在创建它的线程。</p><p>首先来看看<code>Handler</code>的构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Handler``(Callback callback, boolean async) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注到<code>Looper.myLooper()</code>，它是从<code>ThreadLocal</code>中获取到的，而之所以能得到，是因为在执行<code>Looper.prepare()</code>方法时会创建一个<code>Looper</code>实例存入其中，这也就是为什么我们在手动建立消息循环时必须要执行<code>Looper.prepare()</code>的原因了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面<code>sThreadLocal</code>被<code>static final</code>所修饰，也就是说它以常量的形式存在于进程中，所以我们应用进程中的所有<code>Looper</code>实例都会独立存储在其中，无论运行在主线程还是其他线程。<code>ThreadLocal#get()</code>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    // 1.  拿到当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 2.  取出当前线程的独立数据</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            // 3. 取出运行在当前线程的 Looper 实例</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，从<code>ThreadLocal</code>取出<code>Looper</code>实例时会根据当前运行的线程去取，也就是说在<code>Handler</code>执行于的线程决定于<code>Looper</code>所执行于的线程，也就是创建它的，并执行了<code>Looper#prepare()</code>的线程。</p><p>好了，接下来将结合源码分析<code>Handler</code>、<code>Looper</code>、<code>ThreadLocal</code>、<code>MessageQueue</code>、<code>Message</code>的具体运作原理。</p><h3 id="三、-Looper-源码分析"><a href="#三、-Looper-源码分析" class="headerlink" title="三、 Looper 源码分析"></a>三、 Looper 源码分析</h3><p>在<code>Looper</code>对象创建时会创建一个消息队列，并记录当前线程信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上调用<code>Looper.prepare()</code>时才会真正意义上的创建<code>Looper</code>对象，<code>Looper</code>对象会记录在<code>ThreadLocal</code>中，而<code>ThreadLocal</code>在这里是个<code>static final</code>常量，意味着会在运行时以常量形式记录在常量池，从而保证使用到<code>Looper</code>的线程都只对应这唯一的<code>ThreadLocal</code>常量，也就保证不同使用到<code>Looper</code>消息循环的线程中都对应着唯一的<code>Looper</code>，且相互之间是独立的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loop()</code>方法则是个<strong>死循环</strong>，所以执行之后，会使得创建它的线程就处于阻塞状态，此时会一直处于从<code>MessageQueue</code>中提取<code>Message</code>的状态，直到调用<code>Looper.quit()</code>方法退出消息队列。<code>Looper.quit()</code>执行后使得<code>queue.next()</code>返回<code>Message</code>为<code>null</code>,<code>Looper</code>也随即退出，线程最终执行结束。</p><p>在消息循环正常执行过程中，会将每个从消息队列中提取到的消息分发给<code>handler#dispatchMessage(msg)</code>处理，这里的<code>msg.target</code>就是<code>Message</code>记录下来的发送它的那个<code>Handler</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    final MessageQueue queue = me.mQueue; </span><br><span class="line">    // . . .</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;  // 拿到的消息为null了，说明消息队列已经退出了，因而退出消息循环</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123; // 分发消息给handler处理</span><br><span class="line">            msg.target.dispatchMessage(msg); </span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            // ...</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>mQueue.quit(false)</code>后消息队列会删除队列内的所有消息，并把根节点<code>Message</code>设置为<code>null</code>（<code>MessageQueue</code>是个单向链表结构，后面会讲到）,所以上面如果<code>queue.next()</code>拿到的消息为<code>null</code>了，就说明消息队列已经退出，因而就会退出<code>Looper#loop()</code>，也就是退出消息循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void quit() &#123;</span><br><span class="line">    mQueue.quit(false);</span><br><span class="line">&#125;</span><br><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // ... </span><br><span class="line">        if (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; </span><br><span class="line">        // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于<code>Handler.dispatchMessage()</code>，源码如下，可见它首先会看看是否给<code>Message</code>设置了回调，如果有，那执行<code>Message</code>的回调方法，如果没有，则看看自己的回调，如果没有再就执行自己的方法；所以<code>Message</code>自身的回调是优先级最高的，其次是自身回调，最后才是自身的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上整个分析流程下来就可以得出如下草图，其中包含了线程切换的概念在内：</p><p><img src="https://upload-images.jianshu.io/upload_images/5879616-b6666bc061a5184f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler机制.png"></p><p>以上便是<code>Handler</code>机制的核心内容，也可以说是<code>Looper</code>的运行流程，当然这还没完，因为我们在分析过程中依然存在其他疑问，比如以单向链表结构为基础的<code>Messagequque</code>为啥这么设计、<code>ThreadLocal</code>为啥能够独立存储线程数据等。</p><h3 id="三、MessageQueue-源码分析"><a href="#三、MessageQueue-源码分析" class="headerlink" title="三、MessageQueue 源码分析"></a>三、MessageQueue 源码分析</h3><p>消息队列顾名思义是用来存放<code>Message</code>的队列，但实际上它不是使用队列，而是以<code>Message</code>为节点的<strong>单链表结构</strong>；它提供<code>enqueueMessage(Message msg, long when)</code>方法用来插入消息，<code>next()</code>来提取消息，它是一个阻塞方法，只有当<code>Looper.quit</code>调用后它才会退出。</p><p>这里重点分析一下它的<code>next()</code>方法，它采用了线程安全设计，并且它也是阻塞式的，我们先来看看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // 1. 遍历单向链表，也就是消息队列，查找尾部节点</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                // 2. 根据消息的执行时间判定是否要返回、处理这条消息</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // 还没轮到它</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123; // 时间到，就是它了</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;  // 删除队尾节点</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 3. 这条消息可以处理了，则标记为正在使用并返回</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 检查消息循环是否退出</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 其他情况，则继续循环等待</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">由于是基于单向链表的设计，因而每次如果想要得到队尾节点都需要遍历整个队列，直到定位到队尾。一旦定位到了队尾，且它不为`null`，那么就会根据消息的执行时间判定是否要返回、处理这条消息，如果还没到点，那么继续循环（也可看成是在等待，如果是异步`isAsynchronous`的,那么就直接使用这个消息，而不需要定位到队尾），直到达到了执行时间，而达到执行时间后，说明这条消息可以处理了，则标记为已用，并返回给`Looper`进行分发。</span><br><span class="line"></span><br><span class="line">![MessageQueue#next.png](https://upload-images.jianshu.io/upload_images/5879616-1f69351f4ecbd2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">至此，是不是有些明白为什么不用查找效率更高的数组或查找树来设计了呢？首先是额外内存损耗的问题，单向链表的空间复杂度肯定比模板库中的队列（需要额外建立`Entry`）要低；然后是这里的执行时间等待问题，实际这里并不需要查找时间复杂度上的最优，因为反正都可能需要等待执行时间，那么遍历就完事了，多耗点时间也无所谓。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再来看看插入消息，与取消息类似，线程安全设计，具体看看注释就行。</span><br></pre></td></tr></table></figure><p>boolean enqueueMessage(Message msg, long when) {<br>    // . . .<br>    synchronized (this) {<br>        if (mQuitting) {  // quit()方法调用后，消息循环已经退出<br>            msg.recycle();<br>            return false;<br>        }<br>        // 标记为正在使用<br>        msg.markInUse();<br>        msg.when = when;<br>        Message p = mMessages;<br>        boolean needWake;<br>        if (p == null || when == 0 || when &lt; p.when) {<br>            // 如果没到执行时间，则直接插在队头<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        } else { // 其他则插入到队尾，比如已经到了执行时间了，那么直接插入到队头，这样就能在下次取消息时执行了<br>            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            //  插入消息到队尾<br>            for (;;) {<br>                prev = p;<br>                p = p.next;<br>                if (p == null || when &lt; p.when) {<br>                    break;<br>                }<br>                if (needWake &amp;&amp; p.isAsynchronous()) {<br>                    needWake = false;<br>                }<br>            }<br>            msg.next = p; // invariant: p == prev.next<br>            prev.next = msg;<br>        }<br>        // …<br>    }<br>    return true;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###  四、ThreadLocal 源码分析</span><br><span class="line"></span><br><span class="line">**特点：** 当多个线程使用同一个`ThreadLocal`时，它可以独立地记录各个线程的数据。</span><br><span class="line"></span><br><span class="line">`ThreadLocal#set(...)`源码如下，可见每当执行`ThreadLocal#set(...)`保存线程数据时，会先查看当前线程是否已经绑定了`ThreadLocalMap`数据集合，如果不存在则创建一个绑定在这个线程。</span><br></pre></td></tr></table></figure><p>public void set(T value) {<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    if (map != null)<br>        map.set(this, value);<br>    else<br>        createMap(t, value);<br>}</p><p>ThreadLocalMap getMap(Thread t) {<br>    return t.threadLocals;<br>}</p><p>void createMap(Thread t, T firstValue) {<br>    t.threadLocals = new ThreadLocalMap(this, firstValue);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再来看看`ThreadLocalMap`的主要构成，看到这样的构成是不是可以联想到`HashTable`和`HashMap`呢？当然，不过不同之处在于，它并没有像`HashTable`那样采用数组+单向链表的设计，也没有像`HashMap`那样采用数组+单向链表+红黑树的设计，而仅仅是一个数组，不过原理都是类似的。</span><br><span class="line"></span><br><span class="line">也就是说，实际上`ThreadLocal`本身并不存储数据，而`ThreadLocal`之所以能够实现单独记录每个使用到它的线程的数据，是因为它为每一个线程都建立了一个独立的`ThreadLocalMap`数据存储对象，并把这个数据存储对象绑定在对应的线程上，当我们需要设置或者获取某一个线程的数据时，那么只需要从这个线程中取出这个数据存储对象，然后写/读数据即可，你看这是不是既简便又能保证数据的独立性。</span><br></pre></td></tr></table></figure><p>static class ThreadLocalMap {<br>    // 真正线程存储数据的地方<br>    static class Entry extends WeakReference&lt;ThreadLocal<?>> {        /** The value associated with this ThreadLocal. */        Object value;         Entry(ThreadLocal<?> k, Object v) {<br>            super(k);<br>            value = v;<br>        }<br>    }<br>    private Entry[] table;<br>    private int size = 0;<br>    private int threshold; // Default to 0<br>    // …<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`ThreadLocal#get()`源码如下:</span><br></pre></td></tr></table></figure><p>public T get() {<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t); //1. 取出当前线程所绑定的的ThreadLocalMap<br>    if (map != null) {<br>        ThreadLocalMap.Entry e = map.getEntry(this); //2. 取出 ThreadLocalMap.Entry<br>        if (e != null) {<br>            @SuppressWarnings(“unchecked”)<br>            T result = (T)e.value;   //3. 取出值<br>            return result;<br>        }<br>    }<br>    return setInitialValue();<br>}</p><pre><code>#### 五、设计思想至此，我们已经结合源码分析了`Handler`机制中所有核心，可能有的童鞋会有所怀疑，`Handler`机制的核心居然不是`Handler`？哈哈，确实不是，`Handler`只是作为整个框架的入口而已，要说核心，那非`Looper`莫属了。纵观整个机制的执行过程及协作关系，不难发现它实际是基于生产者-消费者模型的设计：![生产者-消费者.png](https://upload-images.jianshu.io/upload_images/5879616-6558b1e0e8118394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)为了方便对比，我把前面的Handler机制那张图粘过来这里：![Handler机制.png](https://upload-images.jianshu.io/upload_images/5879616-b6666bc061a5184f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)然后对号入座一下，不难发现，这里的生产者指的是`Thread 2`，任务队列就是我们的`MessageQueue`，而消费者就是`Looper`也就是`Thread 1`，然后你会发现，`Handler`还真的只是个入口。#### 总结本文从`Handler`的基本使用着手，结合源码分析了`Handler`机制中的几个核心类，并总结和下它的设计思想，水平有限，欢迎指正。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
